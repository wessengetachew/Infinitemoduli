
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Arithmetic Explorer - Multi-Canvas Visualization Suite</title>
    <style>
        :root {
            --bg-deep: #0a0e1a;
            --bg-card: #141829;
            --bg-panel: #1a1f35;
            --gold: #FFD700;
            --gold-dim: #B8960A;
            --cyan: #00FFFF;
            --cyan-dim: #008B8B;
            --text-primary: #E8E8E8;
            --text-secondary: #A0A0A0;
            --border: #2a3150;
            --accent-purple: #9F7AEA;
            --accent-green: #48BB78;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 20px;
        }

        .main-container {
            max-width: 2400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, var(--bg-card), var(--bg-panel));
            border-radius: 15px;
            border: 2px solid var(--border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--gold), var(--cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.2em;
            margin-top: 10px;
        }

        .author {
            color: var(--gold-dim);
            margin-top: 15px;
            font-style: italic;
            font-size: 1.1em;
        }

        /* Canvas Grid */
        .viz-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .canvas-panel {
            background: var(--bg-card);
            border-radius: 12px;
            border: 2px solid var(--border);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .canvas-panel:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(255, 215, 0, 0.2);
            border-color: var(--gold-dim);
        }

        .panel-header {
            background: linear-gradient(135deg, var(--bg-panel), var(--bg-card));
            padding: 20px;
            border-bottom: 2px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-size: 1.5em;
            font-weight: 700;
            color: var(--gold);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .panel-subtitle {
            color: var(--cyan-dim);
            font-size: 0.9em;
            margin-top: 5px;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            background: var(--bg-deep);
        }

        .canvas-info {
            padding: 15px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        /* Controls Section */
        .controls-section {
            background: var(--bg-card);
            border-radius: 12px;
            border: 2px solid var(--border);
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .controls-header {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--gold);
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }

        .section-header {
            font-size: 1.3em;
            color: var(--cyan);
            margin: 25px 0 15px 0;
            font-weight: 600;
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-item {
            flex: 1;
            min-width: 250px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-weight: 600;
        }

        .control-value {
            color: var(--gold);
            font-family: 'Courier New', monospace;
            font-weight: 700;
            padding: 4px 12px;
            background: var(--bg-panel);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--bg-panel);
            outline: none;
            -webkit-appearance: none;
            border: 1px solid var(--border);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--gold), var(--cyan));
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--gold), var(--cyan));
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            border: none;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            background: var(--bg-panel);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1em;
            transition: all 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--gold);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        /* Radio and Checkbox Styles */
        .radio-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .radio-option, .checkbox-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: var(--bg-panel);
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .radio-option:hover, .checkbox-option:hover {
            border-color: var(--gold-dim);
            background: var(--bg-card);
        }

        .radio-option input:checked + span,
        .checkbox-option input:checked + span {
            color: var(--gold);
            font-weight: 700;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--gold-dim), var(--gold));
            color: var(--bg-deep);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--cyan-dim), var(--cyan));
            color: var(--bg-deep);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 255, 255, 0.5);
        }

        /* Preset Grid */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }

        .preset-btn {
            padding: 12px;
            background: var(--bg-panel);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-green));
            border-color: var(--gold);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(159, 122, 234, 0.4);
        }

        /* Info Panel */
        .info-panel {
            background: linear-gradient(135deg, var(--bg-panel), var(--bg-card));
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--border);
            margin: 20px 0;
        }

        .info-title {
            font-size: 1.3em;
            color: var(--gold);
            margin-bottom: 15px;
            font-weight: 700;
        }

        .info-content {
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: var(--bg-panel);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid var(--border);
            text-align: center;
        }

        .stat-label {
            color: var(--cyan);
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .stat-value {
            color: var(--gold);
            font-size: 2em;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }

        .stat-details {
            color: var(--text-secondary);
            font-size: 0.85em;
            margin-top: 8px;
            word-wrap: break-word;
        }

        /* Export Section */
        .export-section {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 30px 0;
            padding: 25px;
            background: var(--bg-card);
            border-radius: 12px;
            border: 2px solid var(--border);
        }

        /* Introduction Section */
        .intro-section {
            background: var(--bg-card);
            border-radius: 12px;
            border: 2px solid var(--border);
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .intro-header {
            background: linear-gradient(135deg, var(--bg-panel), var(--bg-card));
            padding: 20px 30px;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 2px solid var(--border);
        }

        .intro-header:hover {
            background: linear-gradient(135deg, var(--bg-card), var(--bg-panel));
        }

        .intro-header h2 {
            color: var(--gold);
            font-size: 1.8em;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #introToggle {
            transition: transform 0.3s;
            display: inline-block;
        }

        #introToggle.collapsed {
            transform: rotate(-90deg);
        }

        .intro-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            padding: 30px;
        }

        .intro-content.collapsed {
            max-height: 0;
            padding: 0 30px;
        }

        .intro-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
        }

        .intro-card {
            background: var(--bg-panel);
            padding: 25px;
            border-radius: 10px;
            border: 2px solid var(--border);
            transition: all 0.3s;
        }

        .intro-card:hover {
            border-color: var(--gold-dim);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.2);
        }

        .intro-card h3 {
            color: var(--cyan);
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid var(--border);
            padding-bottom: 10px;
        }

        .intro-card p {
            color: var(--text-secondary);
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .intro-card p:last-child {
            margin-bottom: 0;
        }

        .intro-card strong {
            color: var(--text-primary);
        }

        .intro-card em {
            color: var(--gold-dim);
            font-style: normal;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 30px;
            border-top: 2px solid var(--border);
            color: var(--text-secondary);
        }

        footer a {
            color: var(--gold);
            text-decoration: none;
            transition: color 0.3s;
        }

        footer a:hover {
            color: var(--cyan);
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .viz-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 900px) {
            .viz-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2em;
            }
        }

        /* Notification */
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--gold), var(--cyan));
            color: var(--bg-deep);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <h1>‚ü® Modular Arithmetic Explorer ‚ü©</h1>
            <div class="subtitle">Multi-Canvas Visualization Suite ¬∑ Ring Theory ¬∑ Number Theory</div>
            <div class="author">Wessen Getachew ¬∑ @7dview</div>
        </header>

        <!-- Introduction Section (Collapsible) -->
        <div class="intro-section">
            <div class="intro-header" onclick="toggleIntro()">
                <h2>
                    <span id="introToggle">‚ñº</span> Introduction & Guide
                </h2>
            </div>
            <div class="intro-content" id="introContent">
                <div class="intro-grid">
                    <div class="intro-card">
                        <h3>üéØ What is This Tool?</h3>
                        <p>
                            This interactive visualization suite explores <strong>modular arithmetic</strong> through multiple geometric and algebraic perspectives. 
                            For a modulus m, we study the ring ‚Ñ§/m‚Ñ§ = {0, 1, 2, ..., m-1} with addition and multiplication mod m.
                        </p>
                        <p>
                            Each of the 4 canvases reveals different structural properties: multiplication tables, geometric representations 
                            on the unit circle, GCD relationships, and coprime density patterns.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>‚äó Canvas 1: Multiplication Table</h3>
                        <p>
                            <strong>What it shows:</strong> The complete multiplication table a √ó b (mod m) for all elements.
                            Each cell (i,j) shows the product of row i and column j reduced modulo m.
                        </p>
                        <p>
                            <strong>Color schemes:</strong>
                            <br>‚Ä¢ <em>Rainbow:</em> Color by result value
                            <br>‚Ä¢ <em>Divisibility:</em> Intensity by number of divisors
                            <br>‚Ä¢ <em>Zero Divisors:</em> Highlights elements where ab ‚â° 0 (mod m)
                            <br>‚Ä¢ <em>Idempotents:</em> Elements where a¬≤ ‚â° a (mod m)
                        </p>
                        <p>
                            <strong>Key insight:</strong> Patterns reveal ring structure, symmetries, and special elements.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>‚óã Canvas 2: Unit Circle - Farey Channels</h3>
                        <p>
                            <strong>What it shows:</strong> Comprehensive visualization of all residues r/m for every modulus from 1 to m, 
                            mapped to concentric rings inside the unit circle. Each ring represents a different modulus, with points at 
                            angles ¬±2œÄr/m showing both positive and negative rotations.
                        </p>
                        <p>
                            <strong>Phase Rotation (r/m):</strong> Control global rotation with fraction r/m, displayed to 17 decimal places.
                            For example, r=1, m=2 gives 180¬∞ rotation; r=1, m=8 gives 45¬∞. This reveals rotational symmetries in the modular structure.
                        </p>
                        <p>
                            <strong>Residue Layers:</strong> Concentric rings from center (m=1) to outer edge (m=your_limit). 
                            Ring radius = m/M √ó maxRadius. Points colored by gcd(r,m): Gold for coprime (gcd=1), 
                            Cyan for prime GCD, gradient for composite.
                        </p>
                        <p>
                            <strong>Connection Modes:</strong>
                            <br>‚Ä¢ <em>Connect r in Each m:</em> Forms polygons on each ring
                            <br>‚Ä¢ <em>Connect r to Next mod r:</em> Radial lines showing how residues project through modular hierarchy
                            <br>‚Ä¢ <em>Dyadic Powers r√ó2‚Åø:</em> Creates cardioid patterns by connecting r, 2r, 4r, 8r, 16r... (only coprime points)
                            <br>‚Ä¢ <em>Highlight Prime GCD:</em> Cyan coloring for points where gcd(r,m) is prime
                        </p>
                        <p>
                            <strong>Key insight:</strong> Visualizes the complete modular lattice structure, showing how residue classes 
                            relate across different moduli. Dyadic connections reveal multiplication by 2 patterns (like times table cardioids). 
                            Phase rotation exposes hidden symmetries. The center represents gcd=1 (coprimality), with œÜ(m) gold points on each ring.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>‚äö Canvas 3: GCD Structure - 3D Sphere</h3>
                        <p>
                            <strong>What it shows:</strong> Interactive 3D sphere visualization mapping pairs (a,b) to spherical coordinates 
                            based on their GCD value. Points are positioned using spherical coordinates (Œ∏, œÜ) where Œ∏ = 2œÄa/m (azimuthal) 
                            and œÜ = œÄb/m (polar), with radius proportional to gcd(a,b).
                        </p>
                        <p>
                            <strong>360¬∞ Rotation Control:</strong> Two sliders control X-axis and Y-axis rotation independently (0-360¬∞).
                            Zoom slider adjusts view distance (50%-200%). Auto-rotate option continuously spins the sphere. 
                            Reset button returns to default view (45¬∞, 45¬∞, 100%).
                        </p>
                        <p>
                            <strong>Interactive Features:</strong>
                            <br>‚Ä¢ <em>Rotation X/Y:</em> Full 360¬∞ control on both axes - explore from any angle
                            <br>‚Ä¢ <em>Zoom:</em> Adjust perspective from 50% to 200%
                            <br>‚Ä¢ <em>Show Connections:</em> Draw lines between related GCD pairs
                            <br>‚Ä¢ <em>Show Grid:</em> Display latitude/longitude grid with X/Y/Z axes
                            <br>‚Ä¢ <em>Auto-Rotate:</em> Continuous animation for presentation mode
                        </p>
                        <p>
                            <strong>3D Mapping:</strong> Each pair (a,b) with gcd value g maps to 3D coordinates:
                            x = r¬∑sin(œÜ)¬∑cos(Œ∏), y = r¬∑sin(œÜ)¬∑sin(Œ∏), z = r¬∑cos(œÜ), where r = (g/max_gcd)¬∑radius.
                            Perspective projection with depth sorting ensures proper occlusion. Point size and opacity scale with depth 
                            for realistic 3D effect.
                        </p>
                        <p>
                            <strong>Key insight:</strong> The 3D sphere reveals spatial clustering of GCD relationships that aren't 
                            visible in 2D. Coprime pairs (gcd=1, gold) cluster near the surface. Higher GCD values create concentric 
                            shells. Rotation exposes hidden symmetries in the divisibility structure. The spherical topology naturally 
                            represents the periodic nature of modular arithmetic.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>‚ó¨ Canvas 4: Coprime Density</h3>
                        <p>
                            <strong>What it shows:</strong> Plot of œÜ(n)/n for n = 2 to m, where œÜ(n) is Euler's totient function 
                            (count of numbers coprime to n).
                        </p>
                        <p>
                            <strong>Reference line:</strong> Purple dashed line at 6/œÄ¬≤ ‚âà 0.6079, the limiting probability that 
                            two random integers are coprime (Basel problem connection).
                        </p>
                        <p>
                            <strong>Key insight:</strong> Shows how coprime density varies with m and converges toward 6/œÄ¬≤ on average.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>üî¢ Mathematical Concepts</h3>
                        <p>
                            <strong>œÜ(m) - Euler's Totient:</strong> Count of units (invertible elements). For prime p, œÜ(p) = p-1.
                            For prime powers, œÜ(p^k) = p^k - p^(k-1).
                        </p>
                        <p>
                            <strong>Zero Divisors:</strong> Non-zero elements a where ab ‚â° 0 (mod m) for some non-zero b.
                            Present when m is composite. Element a is a zero divisor iff gcd(a,m) > 1.
                        </p>
                        <p>
                            <strong>Idempotents:</strong> Elements satisfying a¬≤ ‚â° a (mod m). Always includes 0 and 1.
                            By Chinese Remainder Theorem, m = p‚ÇÅ^k‚ÇÅ √ó ... √ó p·µ£^k·µ£ has 2^r idempotents.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>üéì Using the Tool</h3>
                        <p>
                            <strong>1. Choose a modulus:</strong> Use slider (2-100) or type directly (up to 500).
                            Try the preset buttons for mathematically significant values.
                        </p>
                        <p>
                            <strong>2. Select table type:</strong>
                            <br>‚Ä¢ <em>Multiplication:</em> Full ring multiplication
                            <br>‚Ä¢ <em>Cayley (Units Only):</em> Just the unit group
                            <br>‚Ä¢ <em>Addition:</em> Addition table structure
                        </p>
                        <p>
                            <strong>3. Explore Farey Channels (Canvas 2):</strong>
                            <br>‚Ä¢ <em>Phase Rotation:</em> Enter r/m fraction to rotate structure (17-decimal precision)
                            <br>‚Ä¢ <em>Connection Modes:</em> Toggle connections to reveal patterns
                            <br>‚Ä¢ <em>Dyadic Powers:</em> Enable for cardioid patterns (like times tables)
                            <br>‚Ä¢ <em>Residue Layers:</em> See all moduli from 1 to m simultaneously
                        </p>
                        <p>
                            <strong>4. Explore presets:</strong> Basel Problem (m=6), Highly Composite (m=60), 
                            Prime Fields (m=17), etc. Each preset demonstrates special properties. After loading a preset, 
                            experiment with Farey channel settings for deeper insights.
                        </p>
                        <p>
                            <strong>5. Export:</strong> Save individual canvases with titles (including phase rotation info), 
                            export all 4 together, or download CSV data for analysis. Circle CSV now includes all residue 
                            layers with GCD values and ring positions.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>üí° Interesting Examples</h3>
                        <p>
                            <strong>m = 6 (Basel Problem):</strong> œÜ(6) = 2. Only 1 and 5 are units. 
                            Related to Œ∂(2) = œÄ¬≤/6 and coprime probability. Try phase r=1, m=6 for 60¬∞ rotation showing 6-fold symmetry.
                        </p>
                        <p>
                            <strong>m = 12:</strong> œÜ(12) = 4. Units are {1,5,7,11}. Rich idempotent structure 
                            with {0,1,4,9} as idempotents. Enable "Connect r in Each m" to see dodecagonal patterns. 
                            Phase r=1, m=2 (180¬∞) reveals binary structure.
                        </p>
                        <p>
                            <strong>m = 17 (Prime):</strong> œÜ(17) = 16. All non-zero elements are units. 
                            Forms a field - no zero divisors. Farey channels show perfect symmetry with all rings having coprime structure.
                        </p>
                        <p>
                            <strong>m = 60 (Highly Composite):</strong> œÜ(60) = 16. Has 60 = 2¬≤√ó3√ó5, 
                            showing rich factorization structure with many zero divisors. Enable "Dyadic Powers r√ó2‚Åø" to see beautiful 
                            cardioid patterns emerging from multiplication by powers of 2.
                        </p>
                        <p>
                            <strong>Dyadic Cardioids:</strong> Set any m ‚â• 30, enable "Dyadic Powers r√ó2‚Åø". Watch how doubling 
                            creates patterns identical to times table visualizations. Try m=100 for stunning complexity.
                        </p>
                        <p>
                            <strong>Phase Exploration:</strong> Try m=8 with phase r=1, m=8 (45¬∞) to see octagonal symmetry. 
                            Or m=12 with r=1, m=3 (120¬∞) for triangular symmetry. The 17-decimal display shows exact rotation angles.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Multi-Canvas Visualization Grid -->
        <div class="viz-grid">
            <!-- Canvas 1: Main Multiplication Grid -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">‚äó Multiplication Table</div>
                        <div class="panel-subtitle">Ring ‚Ñ§/m‚Ñ§ ¬∑ Color-coded Structure</div>
                    </div>
                </div>
                <canvas id="gridCanvas" width="800" height="800"></canvas>
                <div class="canvas-info" id="gridInfo">
                    Multiplication table visualization with configurable color schemes
                </div>
            </div>

            <!-- Canvas 2: Unit Circle Representation -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">‚óã Unit Circle - Farey Channels</div>
                        <div class="panel-subtitle">Modular Residue Channels ¬∑ Phase Rotation ¬∑ Dyadic Lifting</div>
                    </div>
                </div>
                <canvas id="circleCanvas" width="800" height="800"></canvas>
                <div class="canvas-info" id="circleInfo">
                    <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: center;">
                        <div style="flex: 1; min-width: 200px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Phase Rotation (r/m):
                            </label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="number" id="phaseNumerator" value="0" min="0" 
                                       style="width: 80px; padding: 8px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 6px; color: var(--text-primary);"
                                       onchange="updateCircleVisualization()">
                                <span style="color: var(--gold); font-size: 1.3em; font-weight: 700;">/</span>
                                <input type="number" id="phaseDenominator" value="1" min="1" 
                                       style="width: 80px; padding: 8px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 6px; color: var(--text-primary);"
                                       onchange="updateCircleVisualization()">
                            </div>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <label style="color: var(--gold); font-weight: 600; display: block; margin-bottom: 5px;">
                                Rotation Angle (17 decimals):
                            </label>
                            <div id="phaseAngleDisplay" style="font-family: 'Courier New', monospace; color: var(--text-primary); font-size: 1.1em; background: var(--bg-panel); padding: 8px; border-radius: 6px; border: 1px solid var(--border);">
                                0.00000000000000000¬∞
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showResidueLayers" checked onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Show Residue Layers</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="connectByR" onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Connect r in Each m</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="connectToNextMod" onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Connect r to Next mod r</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="connectDyadicPowers" onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Dyadic Powers r√ó2‚Åø</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="highlightPrimeGCD" checked onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Highlight Prime GCD Channels</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Canvas 3: GCD Structure 3D Sphere -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">‚äö GCD Structure - 3D Sphere</div>
                        <div class="panel-subtitle">Interactive 360¬∞ View ¬∑ Coprimality Network</div>
                    </div>
                </div>
                <canvas id="gcdCanvas" width="800" height="800"></canvas>
                <div class="canvas-info" id="gcdInfo">
                    <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: center; margin-bottom: 15px;">
                        <div style="flex: 1; min-width: 200px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Rotation X-axis:
                            </label>
                            <input type="range" id="rotationX" min="0" max="360" value="45" 
                                   style="width: 100%;" oninput="updateGCDVisualization()">
                            <span id="rotXValue" style="color: var(--gold); font-family: monospace;">45¬∞</span>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Rotation Y-axis:
                            </label>
                            <input type="range" id="rotationY" min="0" max="360" value="45" 
                                   style="width: 100%;" oninput="updateGCDVisualization()">
                            <span id="rotYValue" style="color: var(--gold); font-family: monospace;">45¬∞</span>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Zoom:
                            </label>
                            <input type="range" id="zoomLevel" min="50" max="200" value="100" 
                                   style="width: 100%;" oninput="updateGCDVisualization()">
                            <span id="zoomValue" style="color: var(--gold); font-family: monospace;">100%</span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="show3DConnections" checked onchange="updateGCDVisualization()">
                            <span style="color: var(--text-primary);">Show Connections</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showGCDSphereGrid" onchange="updateGCDVisualization()">
                            <span style="color: var(--text-primary);">Show Grid</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="autoRotate" onchange="toggleAutoRotate()">
                            <span style="color: var(--text-primary);">Auto-Rotate</span>
                        </label>
                        <button class="btn btn-secondary" onclick="resetGCD3DView()" style="padding: 8px 15px;">Reset View</button>
                    </div>
                </div>
            </div>

            <!-- Canvas 4: Coprime Density -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">‚ó¨ Coprime Density</div>
                        <div class="panel-subtitle">œÜ(m)/m Analysis</div>
                    </div>
                </div>
                <canvas id="densityCanvas" width="800" height="800"></canvas>
                <div class="canvas-info" id="densityInfo">
                    Visualization of Euler's totient function density
                </div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="controls-section">
            <div class="controls-header">Configuration & Parameters</div>

            <!-- Presets -->
            <div class="section-header">Mathematical Presets</div>
            <div class="preset-grid">
                <button class="preset-btn" onclick="applyPreset('basel')">Œ∂(2)=œÄ¬≤/6 (m=6)</button>
                <button class="preset-btn" onclick="applyPreset('totient12')">œÜ(12)=4</button>
                <button class="preset-btn" onclick="applyPreset('prime')">Prime Field (m=17)</button>
                <button class="preset-btn" onclick="applyPreset('highly_composite')">Highly Composite (m=60)</button>
                <button class="preset-btn" onclick="applyPreset('power_of_2')">Power of 2 (m=32)</button>
                <button class="preset-btn" onclick="applyPreset('fibonacci')">Fibonacci Prime (m=89)</button>
                <button class="preset-btn" onclick="applyPreset('mersenne')">Mersenne Prime (m=31)</button>
                <button class="preset-btn" onclick="applyPreset('perfect')">Perfect Number (m=28)</button>
                <button class="preset-btn" onclick="applyPreset('golden')">Golden Ratio (m‚âà161)</button>
                <button class="preset-btn" onclick="applyPreset('ramanujan')">Ramanujan œÑ (m=24)</button>
            </div>

            <!-- Modulus Control -->
            <div class="section-header">Modulus Parameter</div>
            <div class="control-row">
                <div class="control-item">
                    <div class="control-label">
                        <span>Modulus (m)</span>
                        <span class="control-value" id="modulusDisplay">12</span>
                    </div>
                    <input type="range" id="modulusSlider" min="2" max="100" value="12" oninput="updateModulus()">
                </div>
                <div class="control-item">
                    <label class="control-label">
                        <span>Direct Input</span>
                    </label>
                    <input type="number" id="modulusInput" min="2" max="500" value="12" onchange="updateModulusFromInput()">
                </div>
            </div>

            <!-- Table Type -->
            <div class="section-header">Table Type</div>
            <div class="radio-group">
                <label class="radio-option">
                    <input type="radio" name="tableType" value="multiplication" checked onchange="updateVisualization()">
                    <span>Multiplication</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="tableType" value="cayley" onchange="updateVisualization()">
                    <span>Units Only (Cayley)</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="tableType" value="addition" onchange="updateVisualization()">
                    <span>Addition</span>
                </label>
            </div>

            <!-- Color Scheme -->
            <div class="section-header">Color Scheme</div>
            <div class="radio-group">
                <label class="radio-option">
                    <input type="radio" name="colorScheme" value="rainbow" checked onchange="updateVisualization()">
                    <span>Rainbow</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="colorScheme" value="divisibility" onchange="updateVisualization()">
                    <span>Divisibility</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="colorScheme" value="zeroDivisors" onchange="updateVisualization()">
                    <span>Zero Divisors</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="colorScheme" value="idempotents" onchange="updateVisualization()">
                    <span>Idempotents</span>
                </label>
            </div>

            <!-- Display Options -->
            <div class="section-header">Display Options</div>
            <div class="radio-group">
                <label class="checkbox-option">
                    <input type="checkbox" id="showLabels" checked onchange="updateVisualization()">
                    <span>Show Labels</span>
                </label>
                <label class="checkbox-option">
                    <input type="checkbox" id="showGridLines" onchange="updateVisualization()">
                    <span>Grid Lines</span>
                </label>
                <label class="checkbox-option">
                    <input type="checkbox" id="highlightUnits" onchange="updateVisualization()">
                    <span>Highlight Units</span>
                </label>
            </div>
        </div>

        <!-- Statistics Panel -->
        <div class="info-panel">
            <div class="info-title">Ring Statistics & Properties</div>
            <div class="stat-grid">
                <div class="stat-card">
                    <div class="stat-label">MODULUS</div>
                    <div class="stat-value" id="statModulus">12</div>
                    <div class="stat-details" id="statFactorization">2¬≤ √ó 3</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">UNITS œÜ(m)</div>
                    <div class="stat-value" id="statPhi">4</div>
                    <div class="stat-details" id="statUnitsList">{1,5,7,11}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ZERO DIVISORS</div>
                    <div class="stat-value" id="statZeroDivisors">7</div>
                    <div class="stat-details" id="statZDList">Non-invertible elements</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">IDEMPOTENTS</div>
                    <div class="stat-value" id="statIdempotents">4</div>
                    <div class="stat-details" id="statIdempList">{0,1,4,9}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">RING TYPE</div>
                    <div class="stat-value" id="statField">NO</div>
                    <div class="stat-details">Field Status</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">DENSITY</div>
                    <div class="stat-value" id="statDensity">0.33</div>
                    <div class="stat-details">œÜ(m)/m ratio</div>
                </div>
            </div>
        </div>

        <!-- Export Section -->
        <div class="export-section">
            <h3 style="width: 100%; color: var(--gold); text-align: center; margin-bottom: 20px;">Export Options</h3>
            
            <div style="width: 100%; display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                <button class="btn btn-primary" onclick="exportWithAnalysis()">Export with Full Analysis Panel</button>
                <button class="btn btn-primary" onclick="exportAllCanvases()">Export All 4 Canvases (2√ó2 Grid)</button>
            </div>
            
            <div style="width: 100%; margin: 20px 0;">
                <h4 style="color: var(--cyan); text-align: center; margin-bottom: 15px;">Individual Canvas Exports</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                    <button class="btn btn-secondary" onclick="exportCanvas('grid')">‚äó Grid PNG</button>
                    <button class="btn btn-secondary" onclick="exportCanvas('circle')">‚óã Circle PNG</button>
                    <button class="btn btn-secondary" onclick="exportCanvas('gcd')">‚äö GCD PNG</button>
                    <button class="btn btn-secondary" onclick="exportCanvas('density')">‚ó¨ Density PNG</button>
                </div>
            </div>
            
            <div style="width: 100%; margin: 20px 0;">
                <h4 style="color: var(--cyan); text-align: center; margin-bottom: 15px;">Data Exports (CSV)</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                    <button class="btn btn-secondary" onclick="exportData('grid')">‚äó Grid Data</button>
                    <button class="btn btn-secondary" onclick="exportData('circle')">‚óã Circle Data</button>
                    <button class="btn btn-secondary" onclick="exportData('gcd')">‚äö GCD Data</button>
                    <button class="btn btn-secondary" onclick="exportData('density')">‚ó¨ Density Data</button>
                    <button class="btn btn-secondary" onclick="exportData('all')">All Data Combined</button>
                </div>
            </div>
        </div>

        <footer>
            <p style="font-size: 1.2em; margin-bottom: 15px;">Interactive Mathematical Visualization Tool</p>
            <p>
                Wessen Getachew | 
                <a href="https://github.com/wessengetachew" target="_blank">GitHub</a> | 
                <a href="https://twitter.com/7dview" target="_blank">@7dview</a>
            </p>
            <p style="margin-top: 15px; color: var(--text-secondary); font-size: 0.9em;">
                Exploring connections between modular arithmetic, ring theory, and geometric representations
            </p>
        </footer>
    </div>

    <script>
        // Toggle introduction section
        function toggleIntro() {
            const content = document.getElementById('introContent');
            const toggle = document.getElementById('introToggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '‚ñº';
            } else {
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '‚ñ∂';
            }
        }

        // Initialize intro as collapsed
        window.addEventListener('DOMContentLoaded', function() {
            const content = document.getElementById('introContent');
            const toggle = document.getElementById('introToggle');
            content.classList.add('collapsed');
            toggle.classList.add('collapsed');
            toggle.textContent = '‚ñ∂';
        });

        // Mathematical utility functions
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b !== 0) {
                let t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        function euler_phi(n) {
            if (n === 1) return 1;
            let result = n;
            let p = 2;
            let temp = n;
            while (p * p <= temp) {
                if (temp % p === 0) {
                    while (temp % p === 0) temp /= p;
                    result -= result / p;
                }
                p++;
            }
            if (temp > 1) result -= result / temp;
            return Math.round(result);
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        function findUnits(m) {
            const units = [];
            for (let a = 1; a < m; a++) {
                if (gcd(a, m) === 1) units.push(a);
            }
            return units;
        }

        function findZeroDivisors(m) {
            const zeroDivisors = new Set();
            for (let a = 1; a < m; a++) {
                if (gcd(a, m) > 1) {
                    zeroDivisors.add(a);
                }
            }
            return Array.from(zeroDivisors).sort((a, b) => a - b);
        }

        function findIdempotents(m) {
            const idempotents = [];
            for (let a = 0; a < m; a++) {
                if ((a * a) % m === a) idempotents.push(a);
            }
            return idempotents;
        }

        function getPrimeFactorization(n) {
            if (n === 1) return '1';
            if (isPrime(n)) return `${n} (prime)`;
            
            const factors = [];
            let temp = n;
            let p = 2;
            
            while (p * p <= temp) {
                let count = 0;
                while (temp % p === 0) {
                    count++;
                    temp /= p;
                }
                if (count > 0) {
                    factors.push(count === 1 ? `${p}` : `${p}^${count}`);
                }
                p++;
            }
            if (temp > 1) factors.push(`${temp}`);
            
            return factors.join(' √ó ');
        }

        // Color schemes
        function getRainbowColor(value, m) {
            const hue = (value / m) * 360;
            return `hsl(${hue}, 80%, 60%)`;
        }

        function getDivisibilityColor(value, m) {
            if (value === 0) return '#34495e';
            const divisors = [];
            for (let d = 2; d <= m; d++) {
                if (value % d === 0) divisors.push(d);
            }
            if (divisors.length === 0) return '#48BB78';
            const hue = 240 - (divisors.length / m) * 180;
            return `hsl(${hue}, 70%, 55%)`;
        }

        function getZeroDivisorColor(value, m, zeroDivisors) {
            if (value === 0) return '#2c3e50';
            return zeroDivisors.includes(value) ? '#e74c3c' : '#3498db';
        }

        function getIdempotentColor(value, m, idempotents) {
            if (value === 0) return '#2c3e50';
            return idempotents.includes(value) ? '#FFD700' : '#95a5a6';
        }

        // Preset configurations
        function applyPreset(presetName) {
            const presets = {
                'basel': { m: 6, table: 'multiplication', color: 'zeroDivisors', title: 'Basel Problem', msg: 'Related to Œ∂(2) = œÄ¬≤/6' },
                'totient12': { m: 12, table: 'cayley', color: 'rainbow', title: 'œÜ(12) = 4', msg: 'Classic totient example' },
                'prime': { m: 17, table: 'multiplication', color: 'rainbow', title: 'Prime Field', msg: 'Field structure, all non-zero elements are units' },
                'highly_composite': { m: 60, table: 'multiplication', color: 'divisibility', title: 'Highly Composite', msg: '60 = 2¬≤√ó3√ó5 has many divisors' },
                'power_of_2': { m: 32, table: 'multiplication', color: 'idempotents', title: 'Power of 2', msg: '32 = 2‚Åµ with special structure' },
                'fibonacci': { m: 89, table: 'cayley', color: 'rainbow', title: 'Fibonacci Prime', msg: 'F‚ÇÅ‚ÇÅ = 89 is prime' },
                'mersenne': { m: 31, table: 'multiplication', color: 'rainbow', title: 'Mersenne Prime', msg: '31 = 2‚Åµ - 1' },
                'perfect': { m: 28, table: 'multiplication', color: 'divisibility', title: 'Perfect Number', msg: '28 = 1+2+4+7+14' },
                'golden': { m: 161, table: 'multiplication', color: 'zeroDivisors', title: 'Golden Ratio', msg: '161 ‚âà 100œÜ' },
                'ramanujan': { m: 24, table: 'multiplication', color: 'divisibility', title: 'Ramanujan', msg: 'Related to œÑ function' }
            };

            const preset = presets[presetName];
            if (!preset) return;

            document.getElementById('modulusInput').value = preset.m;
            document.getElementById('modulusSlider').value = Math.min(preset.m, 100);
            document.getElementById('modulusDisplay').textContent = Math.min(preset.m, 100);
            
            document.querySelector(`input[name="tableType"][value="${preset.table}"]`).checked = true;
            document.querySelector(`input[name="colorScheme"][value="${preset.color}"]`).checked = true;
            
            showNotification(preset.title, preset.msg);
            updateVisualization();
        }

        function showNotification(title, message) {
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <h3 style="margin: 0 0 10px 0; font-size: 1.2em;">${title}</h3>
                <p style="margin: 0; line-height: 1.5;">${message}</p>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => notification.remove(), 300);
            }, 5000);
        }

        // Update functions
        function updateModulus() {
            const value = document.getElementById('modulusSlider').value;
            document.getElementById('modulusDisplay').textContent = value;
            document.getElementById('modulusInput').value = value;
            updateVisualization();
        }

        function updateModulusFromInput() {
            const value = parseInt(document.getElementById('modulusInput').value);
            if (value >= 2 && value <= 500) {
                document.getElementById('modulusSlider').value = Math.min(value, 100);
                document.getElementById('modulusDisplay').textContent = Math.min(value, 100);
                updateVisualization();
            }
        }

        // Main visualization function
        function updateVisualization() {
            const m = parseInt(document.getElementById('modulusInput').value);
            const tableType = document.querySelector('input[name="tableType"]:checked').value;
            const colorScheme = document.querySelector('input[name="colorScheme"]:checked').value;
            const showLabels = document.getElementById('showLabels').checked;
            const showGridLines = document.getElementById('showGridLines').checked;
            const highlightUnits = document.getElementById('highlightUnits').checked;

            // Get special elements
            const units = findUnits(m);
            const zeroDivisors = findZeroDivisors(m);
            const idempotents = findIdempotents(m);

            // Draw all canvases
            drawGridCanvas(m, tableType, colorScheme, showLabels, showGridLines, units, zeroDivisors, idempotents);
            drawCircleCanvas(m, units, highlightUnits);
            drawGCDCanvas(m);
            drawDensityCanvas(m);

            // Update statistics
            updateStatistics(m, units, zeroDivisors, idempotents);
        }

        // Canvas 1: Main Grid
        function drawGridCanvas(m, tableType, colorScheme, showLabels, showGridLines, units, zeroDivisors, idempotents) {
            const canvas = document.getElementById('gridCanvas');
            const ctx = canvas.getContext('2d');
            const size = tableType === 'cayley' ? units.length : m;
            const cellSize = Math.floor(canvas.width / size);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const elements = tableType === 'cayley' ? units : Array.from({ length: m }, (_, i) => i);

            for (let i = 0; i < elements.length; i++) {
                for (let j = 0; j < elements.length; j++) {
                    const a = elements[i];
                    const b = elements[j];
                    
                    let value;
                    if (tableType === 'addition') {
                        value = (a + b) % m;
                    } else {
                        value = (a * b) % m;
                    }

                    let color;
                    switch (colorScheme) {
                        case 'rainbow':
                            color = getRainbowColor(value, m);
                            break;
                        case 'divisibility':
                            color = getDivisibilityColor(value, m);
                            break;
                        case 'zeroDivisors':
                            color = getZeroDivisorColor(value, m, zeroDivisors);
                            break;
                        case 'idempotents':
                            color = getIdempotentColor(value, m, idempotents);
                            break;
                    }

                    const x = j * cellSize;
                    const y = i * cellSize;

                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);

                    if (showGridLines && cellSize > 3) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);
                    }

                    if (showLabels && cellSize >= 12) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `bold ${Math.max(8, cellSize / 3)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.shadowBlur = 2;
                        ctx.fillText(value, x + cellSize / 2, y + cellSize / 2);
                        ctx.shadowBlur = 0;
                    }
                }
            }
        }

        // Canvas 2: Unit Circle with Farey Channels
        function drawCircleCanvas(m, units, highlightUnits) {
            const canvas = document.getElementById('circleCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.85;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Get phase rotation parameters
            const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
            const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
            const phaseAngle = (2 * Math.PI * phaseR) / phaseM;
            const phaseAngleDegrees = (360 * phaseR) / phaseM;
            
            // Update angle display with 17 decimal places
            document.getElementById('phaseAngleDisplay').textContent = 
                phaseAngleDegrees.toFixed(17) + '¬∞';

            // Get visualization options
            const showResidueLayers = document.getElementById('showResidueLayers').checked;
            const connectByR = document.getElementById('connectByR').checked;
            const connectToNextMod = document.getElementById('connectToNextMod').checked;
            const connectDyadicPowers = document.getElementById('connectDyadicPowers').checked;
            const highlightPrimeGCD = document.getElementById('highlightPrimeGCD').checked;

            // Store all points for connections
            const pointsByModulus = new Map(); // mod -> [{r, angle, x, y, gcdVal}]
            const pointsByResidue = new Map(); // r -> [{mod, angle, x, y, gcdVal}]

            // Draw concentric rings for each modulus from 1 to m
            if (showResidueLayers) {
                for (let mod = 1; mod <= m; mod++) {
                    const ringRadius = (mod / m) * maxRadius;
                    
                    // Draw ring
                    ctx.strokeStyle = `hsla(${(mod / m) * 360}, 60%, 50%, 0.3)`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, ringRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Label modulus
                    if (mod % Math.max(1, Math.floor(m / 10)) === 0 || mod === 1 || mod === m) {
                        ctx.fillStyle = '#718096';
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(`m=${mod}`, centerX + ringRadius + 5, centerY);
                    }
                }
            }

            // Draw all residues r/mod for each modulus
            for (let mod = 1; mod <= m; mod++) {
                const ringRadius = (mod / m) * maxRadius;
                
                if (!pointsByModulus.has(mod)) {
                    pointsByModulus.set(mod, []);
                }
                
                for (let r = 0; r < mod; r++) {
                    const gcdVal = gcd(r, mod);
                    
                    // Calculate angle: 2œÄr/mod + phase rotation
                    let angle = (2 * Math.PI * r) / mod + phaseAngle;
                    // Also map -2œÄr/mod
                    let angleNeg = -(2 * Math.PI * r) / mod + phaseAngle;
                    
                    // Normalize to [0, 2œÄ)
                    angle = ((angle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                    angleNeg = ((angleNeg % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                    
                    // Position on ring
                    const x = centerX + ringRadius * Math.cos(angle - Math.PI / 2);
                    const y = centerY + ringRadius * Math.sin(angle - Math.PI / 2);
                    
                    const xNeg = centerX + ringRadius * Math.cos(angleNeg - Math.PI / 2);
                    const yNeg = centerY + ringRadius * Math.sin(angleNeg - Math.PI / 2);
                    
                    // Determine color based on GCD
                    let color;
                    if (gcdVal === 1) {
                        color = '#FFD700'; // Gold for coprime (units)
                    } else if (isPrime(gcdVal) && highlightPrimeGCD) {
                        color = '#00FFFF'; // Cyan for prime GCD
                    } else {
                        const hue = (gcdVal / mod) * 360;
                        color = `hsl(${hue}, 70%, 60%)`;
                    }
                    
                    // Draw point for +2œÄr/mod
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    const pointSize = gcdVal === 1 ? 4 : 3;
                    ctx.arc(x, y, pointSize, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw point for -2œÄr/mod (if r > 0)
                    if (r > 0) {
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(xNeg, yNeg, pointSize * 0.8, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                    
                    // Store point data
                    const pointData = { r, angle, x, y, gcdVal, mod };
                    pointsByModulus.get(mod).push(pointData);
                    
                    if (!pointsByResidue.has(r)) {
                        pointsByResidue.set(r, []);
                    }
                    pointsByResidue.get(r).push(pointData);
                    
                    // Label important points
                    if (mod === m && gcdVal === 1) {
                        const labelRadius = ringRadius * 1.08;
                        const labelX = centerX + labelRadius * Math.cos(angle - Math.PI / 2);
                        const labelY = centerY + labelRadius * Math.sin(angle - Math.PI / 2);
                        
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`${r}/${mod}`, labelX, labelY);
                    }
                }
            }

            // Connect r in each modulus
            if (connectByR) {
                pointsByModulus.forEach((points, mod) => {
                    points.sort((a, b) => a.r - b.r);
                    ctx.strokeStyle = `hsla(${(mod / m) * 360}, 60%, 50%, 0.3)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let i = 0; i < points.length; i++) {
                        const p = points[i];
                        if (i === 0) {
                            ctx.moveTo(p.x, p.y);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                    // Close the loop
                    if (points.length > 0) {
                        ctx.lineTo(points[0].x, points[0].y);
                    }
                    ctx.stroke();
                });
            }

            // Connect same residue r across different moduli
            if (connectToNextMod) {
                pointsByResidue.forEach((points, r) => {
                    if (r === 0) return; // Skip r=0
                    
                    points.sort((a, b) => a.mod - b.mod);
                    
                    const hue = (r / m) * 360;
                    ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.4)`;
                    ctx.lineWidth = 1.5;
                    
                    ctx.beginPath();
                    for (let i = 0; i < points.length; i++) {
                        const p = points[i];
                        if (i === 0) {
                            ctx.moveTo(p.x, p.y);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                    ctx.stroke();
                });
            }

            // Connect dyadic powers r, 2r, 4r, 8r, ... (mod appropriate moduli)
            if (connectDyadicPowers) {
                for (let baseR = 1; baseR < m; baseR++) {
                    const dyadicPoints = [];
                    
                    // Find all points r√ó2^n for various n and moduli
                    for (let mod = 1; mod <= m; mod++) {
                        for (let n = 0; n <= 10; n++) { // Up to 2^10
                            const r = (baseR * Math.pow(2, n)) % mod;
                            
                            if (pointsByModulus.has(mod)) {
                                const points = pointsByModulus.get(mod);
                                const match = points.find(p => p.r === r);
                                if (match && gcd(r, mod) === 1) {
                                    dyadicPoints.push(match);
                                }
                            }
                        }
                    }
                    
                    // Draw connections
                    if (dyadicPoints.length > 1) {
                        const hue = (baseR / m) * 360;
                        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, 0.3)`;
                        ctx.lineWidth = 2;
                        
                        ctx.beginPath();
                        for (let i = 0; i < dyadicPoints.length - 1; i++) {
                            ctx.moveTo(dyadicPoints[i].x, dyadicPoints[i].y);
                            ctx.lineTo(dyadicPoints[i + 1].x, dyadicPoints[i + 1].y);
                        }
                        ctx.stroke();
                    }
                }
            }

            // Draw outer circle (m-ring)
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius, 0, 2 * Math.PI);
            ctx.stroke();

            // Center point
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Center label
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GCD=1', centerX, centerY - 12);
        }

        // Separate function to update just the circle canvas
        function updateCircleVisualization() {
            const m = parseInt(document.getElementById('modulusInput').value);
            const units = findUnits(m);
            const highlightUnits = document.getElementById('highlightUnits')?.checked || false;
            drawCircleCanvas(m, units, highlightUnits);
        }


        // Canvas 3: GCD Structure - 3D Sphere
        let autoRotateInterval = null;
        
        function drawGCDCanvas(m) {
            const canvas = document.getElementById('gcdCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Get rotation parameters
            const rotX = (document.getElementById('rotationX')?.value || 45) * Math.PI / 180;
            const rotY = (document.getElementById('rotationY')?.value || 45) * Math.PI / 180;
            const zoom = (document.getElementById('zoomLevel')?.value || 100) / 100;
            const showConnections = document.getElementById('show3DConnections')?.checked !== false;
            const showGrid = document.getElementById('showGCDSphereGrid')?.checked || false;
            
            // Update display values
            if (document.getElementById('rotXValue')) {
                document.getElementById('rotXValue').textContent = Math.round(rotX * 180 / Math.PI) + '¬∞';
            }
            if (document.getElementById('rotYValue')) {
                document.getElementById('rotYValue').textContent = Math.round(rotY * 180 / Math.PI) + '¬∞';
            }
            if (document.getElementById('zoomValue')) {
                document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
            }

            const baseRadius = Math.min(centerX, centerY) * 0.7 * zoom;

            // 3D rotation matrices
            function rotateX(point, angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return {
                    x: point.x,
                    y: point.y * cos - point.z * sin,
                    z: point.y * sin + point.z * cos
                };
            }

            function rotateY(point, angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return {
                    x: point.x * cos + point.z * sin,
                    y: point.y,
                    z: -point.x * sin + point.z * cos
                };
            }

            function project3D(point) {
                // Apply rotations
                let rotated = rotateY(point, rotY);
                rotated = rotateX(rotated, rotX);
                
                // Perspective projection
                const perspective = 1000;
                const scale = perspective / (perspective + rotated.z);
                
                return {
                    x: centerX + rotated.x * scale,
                    y: centerY + rotated.y * scale,
                    z: rotated.z,
                    scale: scale
                };
            }

            // Calculate positions for all elements on sphere
            const points3D = [];
            const maxGCD = Math.floor(m / 2);
            
            for (let a = 0; a < m; a++) {
                for (let b = a + 1; b < m; b++) {
                    const g = gcd(a, b);
                    if (g >= 1) {
                        // Map to sphere using spherical coordinates
                        const theta = (2 * Math.PI * a) / m; // azimuthal
                        const phi = Math.PI * b / m; // polar
                        const r = (g / Math.max(maxGCD, 1)) * baseRadius;
                        
                        const x = r * Math.sin(phi) * Math.cos(theta);
                        const y = r * Math.sin(phi) * Math.sin(theta);
                        const z = r * Math.cos(phi);
                        
                        points3D.push({
                            a, b, g,
                            x3d: x, y3d: y, z3d: z,
                            r: r
                        });
                    }
                }
            }

            // Project all points
            points3D.forEach(p => {
                const proj = project3D({ x: p.x3d, y: p.y3d, z: p.z3d });
                p.x2d = proj.x;
                p.y2d = proj.y;
                p.depth = proj.z;
                p.scale = proj.scale;
            });

            // Sort by depth (back to front)
            points3D.sort((a, b) => a.depth - b.depth);

            // Draw sphere grid if enabled
            if (showGrid) {
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.15)';
                ctx.lineWidth = 1;
                
                // Latitude lines
                for (let lat = 0; lat <= 10; lat++) {
                    const phi = Math.PI * lat / 10;
                    ctx.beginPath();
                    for (let lon = 0; lon <= 40; lon++) {
                        const theta = 2 * Math.PI * lon / 40;
                        const x = baseRadius * Math.sin(phi) * Math.cos(theta);
                        const y = baseRadius * Math.sin(phi) * Math.sin(theta);
                        const z = baseRadius * Math.cos(phi);
                        const proj = project3D({ x, y, z });
                        if (lon === 0) {
                            ctx.moveTo(proj.x, proj.y);
                        } else {
                            ctx.lineTo(proj.x, proj.y);
                        }
                    }
                    ctx.stroke();
                }
                
                // Longitude lines
                for (let lon = 0; lon < 12; lon++) {
                    const theta = 2 * Math.PI * lon / 12;
                    ctx.beginPath();
                    for (let lat = 0; lat <= 20; lat++) {
                        const phi = Math.PI * lat / 20;
                        const x = baseRadius * Math.sin(phi) * Math.cos(theta);
                        const y = baseRadius * Math.sin(phi) * Math.sin(theta);
                        const z = baseRadius * Math.cos(phi);
                        const proj = project3D({ x, y, z });
                        if (lat === 0) {
                            ctx.moveTo(proj.x, proj.y);
                        } else {
                            ctx.lineTo(proj.x, proj.y);
                        }
                    }
                    ctx.stroke();
                }
            }

            // Draw connections if enabled
            if (showConnections) {
                points3D.forEach(p => {
                    if (p.g > 1) {
                        // Find corresponding a and b points
                        const aPoint = points3D.find(pt => pt.a === p.a && pt.b === p.a + 1);
                        const bPoint = points3D.find(pt => pt.a === p.b && pt.b === p.b + 1);
                        
                        if (aPoint) {
                            const hue = (p.g / maxGCD) * 360;
                            const alpha = 0.15 + 0.2 * (p.scale - 0.5);
                            ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${Math.max(0.1, alpha)})`;
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(p.x2d, p.y2d);
                            ctx.lineTo(aPoint.x2d, aPoint.y2d);
                            ctx.stroke();
                        }
                    }
                });
            }

            // Draw points
            points3D.forEach(p => {
                const hue = (p.g / Math.max(maxGCD, 1)) * 360;
                const brightness = 40 + 40 * p.scale;
                const alpha = 0.3 + 0.7 * p.scale;
                
                ctx.fillStyle = `hsla(${hue}, 70%, ${brightness}%, ${alpha})`;
                const size = (p.g === 1 ? 3 : 2) * p.scale;
                
                ctx.beginPath();
                ctx.arc(p.x2d, p.y2d, size, 0, 2 * Math.PI);
                ctx.fill();
                
                // Highlight coprime points
                if (p.g === 1) {
                    ctx.strokeStyle = `rgba(255, 215, 0, ${alpha * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Draw axes if grid is shown
            if (showGrid) {
                const axisLength = baseRadius * 1.2;
                const axes = [
                    { dir: { x: axisLength, y: 0, z: 0 }, color: '#FF6B6B', label: 'X' },
                    { dir: { x: 0, y: axisLength, z: 0 }, color: '#4ECDC4', label: 'Y' },
                    { dir: { x: 0, y: 0, z: axisLength }, color: '#95E1D3', label: 'Z' }
                ];
                
                axes.forEach(axis => {
                    const proj = project3D(axis.dir);
                    ctx.strokeStyle = axis.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(proj.x, proj.y);
                    ctx.stroke();
                    
                    ctx.fillStyle = axis.color;
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(axis.label, proj.x, proj.y);
                });
            }

            // Center sphere outline
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseRadius, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function updateGCDVisualization() {
            const m = parseInt(document.getElementById('modulusInput').value);
            drawGCDCanvas(m);
        }

        function resetGCD3DView() {
            document.getElementById('rotationX').value = 45;
            document.getElementById('rotationY').value = 45;
            document.getElementById('zoomLevel').value = 100;
            updateGCDVisualization();
        }

        function toggleAutoRotate() {
            const enabled = document.getElementById('autoRotate').checked;
            
            if (enabled) {
                autoRotateInterval = setInterval(() => {
                    const rotY = document.getElementById('rotationY');
                    rotY.value = (parseInt(rotY.value) + 1) % 360;
                    updateGCDVisualization();
                }, 50);
            } else {
                if (autoRotateInterval) {
                    clearInterval(autoRotateInterval);
                    autoRotateInterval = null;
                }
            }
        }

        // Canvas 4: Coprime Density
        function drawDensityCanvas(m) {
            const canvas = document.getElementById('densityCanvas');
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Plot density for n = 2 to m
            const padding = 60;
            const graphWidth = canvas.width - 2 * padding;
            const graphHeight = canvas.height - 2 * padding;

            // Axes
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();

            // Plot points
            for (let n = 2; n <= m; n++) {
                const phi = euler_phi(n);
                const density = phi / n;
                const x = padding + (n / m) * graphWidth;
                const y = canvas.height - padding - density * graphHeight;

                ctx.fillStyle = n === m ? '#FFD700' : '#00FFFF';
                ctx.beginPath();
                ctx.arc(x, y, n === m ? 6 : 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Reference line for 6/œÄ¬≤
            const sixOverPiSquared = 6 / (Math.PI * Math.PI);
            const refY = canvas.height - padding - sixOverPiSquared * graphHeight;
            ctx.strokeStyle = '#9F7AEA';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, refY);
            ctx.lineTo(canvas.width - padding, refY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('œÜ(n)/n', padding / 2, canvas.height / 2);
            ctx.fillText('n', canvas.width / 2, canvas.height - padding / 2);
            
            ctx.fillStyle = '#9F7AEA';
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('6/œÄ¬≤ ‚âà 0.608', canvas.width - padding - 10, refY - 10);
        }

        // Update statistics
        function updateStatistics(m, units, zeroDivisors, idempotents) {
            document.getElementById('statModulus').textContent = m;
            document.getElementById('statFactorization').textContent = getPrimeFactorization(m);
            
            document.getElementById('statPhi').textContent = units.length;
            const unitsDisplay = units.length <= 20 ? `{${units.join(',')}}` : `{${units.slice(0, 20).join(',')}, ...}`;
            document.getElementById('statUnitsList').textContent = unitsDisplay;
            
            document.getElementById('statZeroDivisors').textContent = zeroDivisors.length;
            const zdDisplay = zeroDivisors.length <= 20 ? `{${zeroDivisors.join(',')}}` : `{${zeroDivisors.slice(0, 20).join(',')}, ...}`;
            document.getElementById('statZDList').textContent = zdDisplay;
            
            document.getElementById('statIdempotents').textContent = idempotents.length;
            const idDisplay = idempotents.length <= 20 ? `{${idempotents.join(',')}}` : `{${idempotents.slice(0, 20).join(',')}, ...}`;
            document.getElementById('statIdempList').textContent = idDisplay;
            
            document.getElementById('statField').textContent = isPrime(m) ? 'YES' : 'NO';
            document.getElementById('statDensity').textContent = (units.length / m).toFixed(3);
        }

        // Export functions with titles and descriptions
        function exportCanvas(canvasId) {
            const m = parseInt(document.getElementById('modulusInput').value);
            const tableType = document.querySelector('input[name="tableType"]:checked').value;
            const colorScheme = document.querySelector('input[name="colorScheme"]:checked').value;
            const units = findUnits(m);
            const zeroDivisors = findZeroDivisors(m);
            const idempotents = findIdempotents(m);
            
            // Get phase rotation for circle canvas
            const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
            const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
            const phaseAngleDeg = (360 * phaseR) / phaseM;
            
            // Count total residues in all layers
            const totalResidues = (m * (m + 1)) / 2;
            
            // Count coprime pairs for GCD
            let coprimePairs = 0;
            for (let a = 0; a < m; a++) {
                for (let b = a + 1; b < m; b++) {
                    if (gcd(a, b) === 1) coprimePairs++;
                }
            }
            
            const canvasMap = {
                'grid': { 
                    id: 'gridCanvas', 
                    title: '‚äó Multiplication Table',
                    subtitle: `‚Ñ§/${m}‚Ñ§ (m=${m}) ¬∑ ${tableType} ¬∑ ${colorScheme} ¬∑ œÜ(${m})=${units.length} units ¬∑ ${zeroDivisors.length} zero divisors`
                },
                'circle': { 
                    id: 'circleCanvas', 
                    title: '‚óã Unit Circle - Farey Channels',
                    subtitle: `m=${m} ¬∑ Layers 1‚Üí${m} (${totalResidues} residues) ¬∑ Phase ${phaseR}/${phaseM} = ${phaseAngleDeg.toFixed(3)}¬∞ ¬∑ œÜ(${m})=${units.length}`
                },
                'gcd': { 
                    id: 'gcdCanvas', 
                    title: '‚äö GCD Structure - 3D Sphere',
                    subtitle: `m=${m} ¬∑ 3D Spherical View ¬∑ ${coprimePairs} coprime pairs ¬∑ œÜ(${m})=${units.length} ¬∑ Density ${(units.length/m).toFixed(4)}`
                },
                'density': { 
                    id: 'densityCanvas', 
                    title: '‚ó¨ Coprime Density Analysis',
                    subtitle: `m=${m} ¬∑ œÜ(m)/m = ${(units.length/m).toFixed(6)} ¬∑ Basel limit 6/œÄ¬≤ ‚âà 0.6079 ¬∑ ${m} data points`
                }
            };
            
            const info = canvasMap[canvasId];
            const canvas = document.getElementById(info.id);
            
            // Create export canvas with title and description
            const exportCanvas = document.createElement('canvas');
            const margin = 200;
            exportCanvas.width = 3840;
            exportCanvas.height = 3840 + margin;
            const ctx = exportCanvas.getContext('2d', { alpha: false });
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Draw title
            ctx.fillStyle = '#1a202c';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(info.title, exportCanvas.width / 2, 80);
            
            // Draw subtitle (with metrics)
            ctx.font = '38px Arial';
            ctx.fillStyle = '#4a5568';
            
            // Split long subtitle into multiple lines if needed
            const maxWidth = exportCanvas.width - 200;
            const words = info.subtitle.split(' ¬∑ ');
            let lines = [];
            let currentLine = words[0];
            
            for (let i = 1; i < words.length; i++) {
                const testLine = currentLine + ' ¬∑ ' + words[i];
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && i > 0) {
                    lines.push(currentLine);
                    currentLine = words[i];
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine);
            
            let subtitleY = 130;
            for (let line of lines) {
                ctx.fillText(line, exportCanvas.width / 2, subtitleY);
                subtitleY += 45;
            }
            
            // Draw canvas
            ctx.save();
            ctx.translate(0, margin);
            const sourceCanvas = document.getElementById(info.id);
            ctx.scale(3840 / sourceCanvas.width, 3840 / sourceCanvas.height);
            ctx.drawImage(sourceCanvas, 0, 0);
            ctx.restore();
            
            // ========== ADD LEGEND PANEL TO RIGHT SIDE ==========
            const legendWidth = 700;
            const legendX = 3840 + 50;
            const legendY = margin + 50;
            const legendHeight = 3840 - 100;
            
            // Expand canvas width to include legend
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = 3840 + legendWidth + 100;
            finalCanvas.height = 3840 + margin;
            const finalCtx = finalCanvas.getContext('2d', { alpha: false });
            
            // Copy everything we've drawn so far
            finalCtx.fillStyle = '#ffffff';
            finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
            finalCtx.drawImage(exportCanvas, 0, 0);
            
            // Now draw legend on final canvas
            finalCtx.fillStyle = '#f7fafc';
            finalCtx.fillRect(legendX - 20, legendY - 20, legendWidth + 40, legendHeight + 40);
            finalCtx.strokeStyle = '#cbd5e0';
            finalCtx.lineWidth = 4;
            finalCtx.strokeRect(legendX - 20, legendY - 20, legendWidth + 40, legendHeight + 40);
            
            finalCtx.fillStyle = '#2d3748';
            finalCtx.font = 'bold 56px Arial';
            finalCtx.textAlign = 'left';
            finalCtx.fillText('Legend', legendX, legendY + 50);
            
            let yPos = legendY + 120;
            const lineHeight = 46;
            const sectionGap = 60;
            const smallFont = '34px Arial';
            const mediumFont = '38px Arial';
            
            // Modulus info
            finalCtx.font = 'bold 46px Arial';
            finalCtx.fillStyle = '#667eea';
            finalCtx.fillText('Modulus', legendX, yPos);
            yPos += lineHeight + 8;
            
            finalCtx.font = mediumFont;
            finalCtx.fillStyle = '#2d3748';
            finalCtx.fillText(`m = ${m}`, legendX, yPos);
            yPos += lineHeight;
            
            finalCtx.font = smallFont;
            finalCtx.fillStyle = '#4a5568';
            finalCtx.fillText(`${getPrimeFactorization(m)}`, legendX + 15, yPos);
            yPos += lineHeight;
            
            if (isPrime(m)) {
                finalCtx.fillStyle = '#48BB78';
                finalCtx.fillText(`‚úì Prime (Field)`, legendX + 15, yPos);
            } else {
                finalCtx.fillStyle = '#718096';
                finalCtx.fillText(`Composite`, legendX + 15, yPos);
            }
            yPos += sectionGap;
            
            // Units
            finalCtx.font = 'bold 46px Arial';
            finalCtx.fillStyle = '#667eea';
            finalCtx.fillText('Units (‚Ñ§/m‚Ñ§)√ó', legendX, yPos);
            yPos += lineHeight + 8;
            
            finalCtx.font = mediumFont;
            finalCtx.fillStyle = '#2d3748';
            finalCtx.fillText(`œÜ(${m}) = ${units.length}`, legendX, yPos);
            yPos += lineHeight;
            
            finalCtx.font = smallFont;
            finalCtx.fillStyle = '#4a5568';
            const density = units.length / m;
            finalCtx.fillText(`Density: ${density.toFixed(6)}`, legendX + 15, yPos);
            yPos += lineHeight;
            
            const baselLimit = 6 / (Math.PI * Math.PI);
            finalCtx.fillText(`Basel: ${baselLimit.toFixed(6)}`, legendX + 15, yPos);
            yPos += lineHeight;
            
            if (units.length <= 18) {
                const unitStr = `{${units.join(',')}}`;
                const maxLen = 35;
                finalCtx.fillText(unitStr.length > maxLen ? unitStr.substring(0, maxLen) + '..}' : unitStr, legendX + 15, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap;
            
            // Canvas-specific metrics
            if (canvasId === 'grid') {
                // Zero divisors
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Zero Divisors', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`Count: ${zeroDivisors.length}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                finalCtx.fillText(`Density: ${(zeroDivisors.length/m).toFixed(4)}`, legendX + 15, yPos);
                yPos += lineHeight + sectionGap;
                
                // Idempotents
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Idempotents', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`Count: ${idempotents.length}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                if (idempotents.length <= 12) {
                    finalCtx.fillText(`{${idempotents.join(',')}}`, legendX + 15, yPos);
                    yPos += lineHeight;
                }
                yPos += sectionGap;
                
                // Table info
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Table Type', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(tableType, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                finalCtx.fillText(`Colors: ${colorScheme}`, legendX + 15, yPos);
                yPos += lineHeight;
                
            } else if (canvasId === 'circle') {
                // Phase rotation
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Phase Rotation', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`r/m = ${phaseR}/${phaseM}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                finalCtx.fillText(`${phaseAngleDeg.toFixed(6)}¬∞`, legendX + 15, yPos);
                yPos += lineHeight + sectionGap;
                
                // Residue layers
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Residue Layers', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`Total: ${totalResidues}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                finalCtx.fillText(`Layers: 1 to ${m}`, legendX + 15, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`m(m+1)/2`, legendX + 15, yPos);
                yPos += lineHeight;
                
            } else if (canvasId === 'gcd') {
                // 3D View settings
                const rotX = document.getElementById('rotationX')?.value || 45;
                const rotY = document.getElementById('rotationY')?.value || 45;
                const zoom = document.getElementById('zoomLevel')?.value || 100;
                
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('3D View', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`X-axis: ${rotX}¬∞`, legendX, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`Y-axis: ${rotY}¬∞`, legendX, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`Zoom: ${zoom}%`, legendX, yPos);
                yPos += lineHeight + sectionGap;
                
                // Coprime pairs
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Coprime Pairs', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`Count: ${coprimePairs}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                const totalPairs = m * (m - 1) / 2;
                finalCtx.fillText(`Of ${totalPairs} pairs`, legendX + 15, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`${(coprimePairs/totalPairs*100).toFixed(2)}%`, legendX + 15, yPos);
                yPos += lineHeight;
                
            } else if (canvasId === 'density') {
                // Basel connection
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Basel Problem', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`6/œÄ¬≤ ‚âà 0.608`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                const baselRatio = density / baselLimit;
                finalCtx.fillText(`Ratio: ${baselRatio.toFixed(4)}√ó`, legendX + 15, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`Probability coprime`, legendX + 15, yPos);
                yPos += lineHeight + sectionGap;
                
                // Data range
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Data Points', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`n = 2 to ${m}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                finalCtx.fillText(`${m - 1} values`, legendX + 15, yPos);
                yPos += lineHeight;
            }
            
            // Footer on final canvas
            finalCtx.fillStyle = '#718096';
            finalCtx.font = '36px Arial';
            finalCtx.textAlign = 'center';
            finalCtx.fillText('Wessen Getachew | github.com/wessengetachew | @7dview', finalCanvas.width / 2, finalCanvas.height - 50);
            finalCtx.font = '32px Arial';
            finalCtx.fillText(new Date().toLocaleDateString(), finalCanvas.width / 2, finalCanvas.height - 15);
            
            finalCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `modular_${canvasId}_m${m}_with_legend.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
            
            showNotification('Export Complete', `${info.title} exported with comprehensive legend`);
        }

        function exportAllCanvases() {
            const m = parseInt(document.getElementById('modulusInput').value);
            const units = findUnits(m);
            const zeroDivisors = findZeroDivisors(m);
            const idempotents = findIdempotents(m);
            const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
            const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
            const totalResidues = (m * (m + 1)) / 2;
            const coprimeDensity = units.length / m;
            
            const canvases = [
                { 
                    id: 'gridCanvas', 
                    title: '‚äó Multiplication Table',
                    metrics: `œÜ(${m})=${units.length} units`
                },
                { 
                    id: 'circleCanvas', 
                    title: '‚óã Farey Channels',
                    metrics: `${totalResidues} residues ¬∑ Phase ${phaseR}/${phaseM}`
                },
                { 
                    id: 'gcdCanvas', 
                    title: '‚äö GCD 3D Sphere',
                    metrics: `360¬∞ rotation ¬∑ Density ${coprimeDensity.toFixed(4)}`
                },
                { 
                    id: 'densityCanvas', 
                    title: '‚ó¨ Coprime Density',
                    metrics: `œÜ(m)/m trend ¬∑ Basel 6/œÄ¬≤`
                }
            ];
            
            // Create wider canvas to include legend
            const margin = 250;
            const legendWidth = 900;
            const gridWidth = 3840 * 2;
            const gridHeight = 3840 * 2;
            
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = gridWidth + legendWidth;
            exportCanvas.height = gridHeight + margin;
            const ctx = exportCanvas.getContext('2d', { alpha: false });
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Main title
            ctx.fillStyle = '#1a202c';
            ctx.font = 'bold 96px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Modular Arithmetic Explorer', gridWidth / 2, 100);
            
            // Subtitle with m and key metrics
            ctx.font = '56px Arial';
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`m = ${m} ¬∑ Ring ‚Ñ§/${m}‚Ñ§ ¬∑ œÜ(${m}) = ${units.length} ¬∑ Prime: ${isPrime(m) ? 'Yes' : 'No'}`, gridWidth / 2, 180);
            
            // Draw 2x2 grid of canvases
            canvases.forEach((info, idx) => {
                const canvas = document.getElementById(info.id);
                const col = idx % 2;
                const row = Math.floor(idx / 2);
                const x = col * 3840;
                const y = row * 3840 + margin;
                
                // Draw border
                ctx.strokeStyle = '#cbd5e0';
                ctx.lineWidth = 4;
                ctx.strokeRect(x, y, 3840, 3840);
                
                // Draw canvas
                ctx.save();
                ctx.translate(x, y);
                const sourceCanvas = document.getElementById(info.id);
                ctx.scale(3840 / sourceCanvas.width, 3840 / sourceCanvas.height);
                ctx.drawImage(sourceCanvas, 0, 0);
                ctx.restore();
                
                // Draw title at top of each panel
                ctx.fillStyle = '#2d3748';
                ctx.font = 'bold 56px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(info.title, x + 1920, y + 80);
                
                // Draw metrics at bottom of each panel
                ctx.font = '40px Arial';
                ctx.fillStyle = '#718096';
                ctx.fillText(info.metrics, x + 1920, y + 3760);
            });
            
            // ========== LEGEND PANEL ON RIGHT ==========
            const legendX = gridWidth + 50;
            const legendY = margin + 50;
            const legendHeight = gridHeight - 100;
            
            ctx.fillStyle = '#f7fafc';
            ctx.fillRect(legendX - 20, legendY - 20, legendWidth - 60, legendHeight + 40);
            ctx.strokeStyle = '#cbd5e0';
            ctx.lineWidth = 5;
            ctx.strokeRect(legendX - 20, legendY - 20, legendWidth - 60, legendHeight + 40);
            
            ctx.fillStyle = '#2d3748';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Legend', legendX, legendY + 70);
            
            let yPos = legendY + 160;
            const lineHeight = 58;
            const sectionGap = 75;
            const smallFont = '42px Arial';
            const mediumFont = '48px Arial';
            
            // Modulus Section
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Modulus', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`m = ${m}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(getPrimeFactorization(m), legendX + 20, yPos);
            yPos += lineHeight;
            
            if (isPrime(m)) {
                ctx.fillStyle = '#48BB78';
                ctx.font = 'bold ' + smallFont;
                ctx.fillText('‚úì PRIME FIELD', legendX + 20, yPos);
            } else {
                ctx.fillStyle = '#718096';
                ctx.fillText('Composite ring', legendX + 20, yPos);
            }
            yPos += sectionGap;
            
            // Units Section
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Units (‚Ñ§/m‚Ñ§)√ó', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`œÜ(${m}) = ${units.length}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`Density: ${coprimeDensity.toFixed(6)}`, legendX + 20, yPos);
            yPos += lineHeight;
            
            const baselLimit = 6 / (Math.PI * Math.PI);
            ctx.fillText(`Basel: ${baselLimit.toFixed(6)}`, legendX + 20, yPos);
            yPos += lineHeight;
            
            const baselRatio = coprimeDensity / baselLimit;
            ctx.fillText(`Ratio: ${baselRatio.toFixed(4)}√ó`, legendX + 20, yPos);
            yPos += sectionGap;
            
            // Special Elements
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Special Elements', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`Zero Divisors: ${zeroDivisors.length}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.fillText(`Idempotents: ${idempotents.length}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            if (idempotents.length <= 12) {
                ctx.fillText(`{${idempotents.join(',')}}`, legendX + 20, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap;
            
            // Canvas Details
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Canvas Details', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`Grid: ${units.length} units`, legendX, yPos);
            yPos += lineHeight;
            
            const phaseAngle = (360 * phaseR) / phaseM;
            ctx.fillText(`Circle: Phase ${phaseAngle.toFixed(1)}¬∞`, legendX, yPos);
            yPos += lineHeight;
            
            const rotX = document.getElementById('rotationX')?.value || 45;
            const rotY = document.getElementById('rotationY')?.value || 45;
            ctx.fillText(`GCD: View ${rotX}¬∞√ó${rotY}¬∞`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.fillText(`Density: ${m-1} points`, legendX, yPos);
            yPos += lineHeight;
            
            yPos += sectionGap;
            
            // Summary Stats
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Summary', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`Total residues: ${totalResidues}`, legendX + 20, yPos);
            yPos += lineHeight;
            
            let coprimePairs = 0;
            for (let a = 0; a < m; a++) {
                for (let b = a + 1; b < m; b++) {
                    if (gcd(a, b) === 1) coprimePairs++;
                }
            }
            ctx.fillText(`Coprime pairs: ${coprimePairs}`, legendX + 20, yPos);
            yPos += lineHeight;
            
            // Footer
            ctx.fillStyle = '#718096';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Wessen Getachew | github.com/wessengetachew | @7dview', exportCanvas.width / 2, exportCanvas.height - 60);
            ctx.font = '40px Arial';
            ctx.fillText(new Date().toLocaleDateString(), exportCanvas.width / 2, exportCanvas.height - 15);
            
            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `modular_all_4_canvases_m${m}_with_legend.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
            
            showNotification('Export Complete', 'All 4 canvases exported with comprehensive legend');
        }

        function exportWithAnalysis() {
            const m = parseInt(document.getElementById('modulusInput').value);
            const tableType = document.querySelector('input[name="tableType"]:checked').value;
            const colorScheme = document.querySelector('input[name="colorScheme"]:checked').value;
            
            const units = findUnits(m);
            const zeroDivisors = findZeroDivisors(m);
            const idempotents = findIdempotents(m);
            const isField = isPrime(m);
            
            // Get phase rotation for circle canvas
            const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
            const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
            const phaseAngleDeg = (360 * phaseR) / phaseM;
            
            // Calculate additional statistics
            const nilpotents = [];
            for (let a = 0; a < m; a++) {
                let temp = a;
                for (let n = 1; n < 20; n++) {
                    temp = (temp * a) % m;
                    if (temp === 0) {
                        nilpotents.push(a);
                        break;
                    }
                }
            }
            
            // Count GCD values
            const gcdDistribution = new Map();
            for (let r = 0; r < m; r++) {
                const g = gcd(r, m);
                gcdDistribution.set(g, (gcdDistribution.get(g) || 0) + 1);
            }
            
            // Calculate coprime density
            const coprimeDensity = units.length / m;
            const baselLimit = 6 / (Math.PI * Math.PI);
            
            // Prime factorization details
            const primeFactors = [];
            let temp = m;
            for (let p = 2; p <= temp; p++) {
                let count = 0;
                while (temp % p === 0) {
                    count++;
                    temp /= p;
                }
                if (count > 0) {
                    primeFactors.push({ prime: p, power: count });
                }
            }
            
            const canvases = [
                { id: 'gridCanvas', title: '‚äó Grid' },
                { id: 'circleCanvas', title: '‚óã Circle' },
                { id: 'gcdCanvas', title: '‚äö GCD' },
                { id: 'densityCanvas', title: '‚ó¨ Density' }
            ];
            
            // Count additional metrics
            const totalResidues = (m * (m + 1)) / 2;
            const rotX = document.getElementById('rotationX')?.value || 45;
            const rotY = document.getElementById('rotationY')?.value || 45;
            const zoom = document.getElementById('zoomLevel')?.value || 100;
            
            let coprimePairs = 0;
            for (let a = 0; a < m; a++) {
                for (let b = a + 1; b < m; b++) {
                    if (gcd(a, b) === 1) coprimePairs++;
                }
            }
            
            const margin = 250;
            const legendWidth = 1000;
            const gridWidth = 3840 * 2;
            const gridHeight = 3840 * 2;
            
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = gridWidth + legendWidth;
            exportCanvas.height = gridHeight + margin;
            const ctx = exportCanvas.getContext('2d', { alpha: false });
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Title
            ctx.fillStyle = '#1a202c';
            ctx.font = 'bold 96px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Modular Arithmetic - Complete Analysis', gridWidth / 2, 100);
            
            // Subtitle
            ctx.font = '56px Arial';
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`m = ${m} ¬∑ Ring ‚Ñ§/${m}‚Ñ§ ¬∑ œÜ(${m}) = ${units.length} ¬∑ Prime: ${isField ? 'Yes' : 'No'}`, gridWidth / 2, 175);
            
            // Draw 2√ó2 grid of ALL canvases
            canvases.forEach((info, idx) => {
                const canvas = document.getElementById(info.id);
                const col = idx % 2;
                const row = Math.floor(idx / 2);
                const x = col * 3840;
                const y = row * 3840 + margin;
                
                // Border
                ctx.strokeStyle = '#cbd5e0';
                ctx.lineWidth = 4;
                ctx.strokeRect(x, y, 3840, 3840);
                
                // Canvas
                ctx.save();
                ctx.translate(x, y);
                const sourceCanvas = document.getElementById(info.id);
                ctx.scale(3840 / sourceCanvas.width, 3840 / sourceCanvas.height);
                ctx.drawImage(sourceCanvas, 0, 0);
                ctx.restore();
                
                // Label
                ctx.fillStyle = '#2d3748';
                ctx.font = 'bold 52px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(info.title, x + 1920, y + 3770);
            });
            
            // ========== COMPREHENSIVE ANALYSIS PANEL ==========
            const legendX = gridWidth + 40;
            const legendY = margin;
            
            ctx.fillStyle = '#f7fafc';
            ctx.fillRect(legendX - 20, legendY - 20, legendWidth - 60, gridHeight + 40);
            ctx.strokeStyle = '#cbd5e0';
            ctx.lineWidth = 5;
            ctx.strokeRect(legendX - 20, legendY - 20, legendWidth - 60, gridHeight + 40);
            
            ctx.fillStyle = '#2d3748';
            ctx.font = 'bold 64px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Analysis', legendX, legendY + 70);
            
            let yPos = legendY + 150;
            const lineHeight = 52;
            const sectionGap = 65;
            const smallFont = '38px Arial';
            const mediumFont = '44px Arial';
            
            // ========== MODULUS PROPERTIES ==========
            ctx.font = 'bold 54px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Modulus', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`m = ${m}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`Prime factorization:`, legendX, yPos);
            yPos += lineHeight;
            ctx.fillText(`${getPrimeFactorization(m)}`, legendX + 20, yPos);
            yPos += lineHeight;
            
            if (isField) {
                ctx.fillStyle = '#48BB78';
                ctx.fillText(`‚úì Prime: Forms a field`, legendX + 20, yPos);
            } else {
                ctx.fillStyle = '#718096';
                ctx.fillText(`Composite: Has zero divisors`, legendX + 20, yPos);
            }
            yPos += sectionGap;
            
            // ========== UNIT GROUP ==========
            ctx.font = 'bold 54px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Unit Group', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`œÜ(${m}) = ${units.length}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`Density: ${coprimeDensity.toFixed(6)}`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`Basel limit: ${baselLimit.toFixed(6)}`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`Ratio: ${(coprimeDensity/baselLimit).toFixed(4)}√ó`, legendX + 20, yPos);
            yPos += lineHeight;
            
            if (units.length <= 20) {
                ctx.fillText(`Units: {${units.join(',')}}`, legendX + 20, yPos);
                yPos += lineHeight;
            } else {
                ctx.fillText(`Units: {${units.slice(0,15).join(',')}, ...}`, legendX + 20, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap - lineHeight;
            
            // ========== ZERO DIVISORS ==========
            ctx.font = 'bold 46px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Zero Divisor Structure', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`Count: ${zeroDivisors.length}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            const zdDensity = zeroDivisors.length / m;
            ctx.fillText(`Density: ${zdDensity.toFixed(6)}`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`Non-zero ZD: ${zeroDivisors.filter(z => z !== 0).length}`, legendX + 20, yPos);
            yPos += lineHeight;
            
            if (zeroDivisors.length > 0 && zeroDivisors.length <= 15) {
                ctx.fillText(`Set: {${zeroDivisors.join(',')}}`, legendX + 20, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap - lineHeight;
            
            // ========== IDEMPOTENT STRUCTURE ==========
            ctx.font = 'bold 46px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Idempotent Structure', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`Count: ${idempotents.length}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            const numPrimeFactors = primeFactors.length;
            const expectedIdempotents = Math.pow(2, numPrimeFactors);
            ctx.fillText(`Expected (2^œâ(m)): ${expectedIdempotents}`, legendX + 20, yPos);
            yPos += lineHeight;
            
            if (idempotents.length <= 15) {
                ctx.fillText(`Set: {${idempotents.join(',')}}`, legendX + 20, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap - lineHeight;
            
            // ========== GCD DISTRIBUTION ==========
            ctx.font = 'bold 46px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('GCD Distribution', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            const sortedGCDs = Array.from(gcdDistribution.keys()).sort((a, b) => a - b);
            let gcdCount = 0;
            for (let g of sortedGCDs.slice(0, 8)) {
                const count = gcdDistribution.get(g);
                ctx.fillText(`gcd=${g}: ${count} elements (${(count/m*100).toFixed(1)}%)`, legendX + 20, yPos);
                yPos += lineHeight;
                gcdCount++;
            }
            if (sortedGCDs.length > 8) {
                ctx.fillText(`... and ${sortedGCDs.length - 8} more`, legendX + 20, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap - lineHeight;
            
            // ========== CANVAS DETAILS ==========
            ctx.font = 'bold 54px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Canvas Details', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`Grid: ${tableType}, ${colorScheme}`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`Circle: Phase ${phaseAngleDeg.toFixed(1)}¬∞, ${totalResidues} res`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`GCD: View ${rotX}¬∞√ó${rotY}¬∞, zoom ${zoom}%`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`Density: ${m-1} points, coprime ${coprimePairs}`, legendX + 20, yPos);
            yPos += sectionGap;
            
            // ========== RING CLASSIFICATION ==========
            ctx.font = 'bold 54px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Classification', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            
            const classifications = [];
            if (isField) classifications.push('Field');
            if (zeroDivisors.length === 0) classifications.push('Integral Domain');
            if (units.length === m - 1) classifications.push('Division Ring');
            if (idempotents.length > 2) classifications.push('Non-trivial Idempotents');
            if (nilpotents.length > 1) classifications.push('Has Nilpotents');
            
            for (let i = 0; i < Math.min(classifications.length, 6); i++) {
                ctx.font = smallFont;
                ctx.fillStyle = '#48BB78';
                ctx.fillText(`‚úì ${classifications[i]}`, legendX + 20, yPos);
                yPos += lineHeight;
            }
            
            if (classifications.length === 0) {
                ctx.fillStyle = '#718096';
                ctx.fillText('General commutative ring', legendX + 20, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap;
            
            // ========== CANVAS DETAILS ==========
            ctx.font = 'bold 46px Arial';
            ctx.fillStyle = '#667eea';
            ctx.fillText('Canvas Details', legendX, yPos);
            yPos += lineHeight + 10;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`‚äó Grid: ${tableType} table`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`‚óã Circle: ${totalResidues} residues`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`   Phase ${phaseR}/${phaseM} = ${phaseAngleDeg.toFixed(1)}¬∞`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`‚äö GCD: 3D view ${rotX}¬∞√ó${rotY}¬∞`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`   ${coprimePairs} coprime pairs`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`‚ó¨ Density: ${m-1} data points`, legendX + 20, yPos);
            yPos += lineHeight;
            ctx.fillText(`   Ratio: ${(coprimeDensity/baselLimit).toFixed(4)}√ó`, legendX + 20, yPos);
            yPos += lineHeight;
            
            // Footer
            ctx.fillStyle = '#718096';
            ctx.font = '36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Wessen Getachew | github.com/wessengetachew | @7dview', exportCanvas.width / 2, exportCanvas.height - 50);
            ctx.font = '32px Arial';
            ctx.fillText(new Date().toLocaleDateString(), exportCanvas.width / 2, exportCanvas.height - 15);
            
            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `modular_all_4_canvases_m${m}_full_analysis.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
            
            showNotification('Export Complete', 'All 4 canvases exported with comprehensive statistical analysis panel');
        }

        function exportData(dataType) {
            const m = parseInt(document.getElementById('modulusInput').value);
            const tableType = document.querySelector('input[name="tableType"]:checked').value;
            
            let csv = '';
            let filename = '';
            
            if (dataType === 'grid' || dataType === 'all') {
                csv += '# Multiplication/Addition Table Data\n';
                csv += '# Modulus m = ' + m + '\n';
                csv += '# Table Type: ' + tableType + '\n';
                csv += 'a,b,result,operation\n';
                
                const elements = tableType === 'cayley' ? findUnits(m) : Array.from({ length: m }, (_, i) => i);
                
                for (let i = 0; i < elements.length; i++) {
                    for (let j = 0; j < elements.length; j++) {
                        const a = elements[i];
                        const b = elements[j];
                        const result = tableType === 'addition' ? (a + b) % m : (a * b) % m;
                        const op = tableType === 'addition' ? 'addition' : 'multiplication';
                        csv += `${a},${b},${result},${op}\n`;
                    }
                }
                csv += '\n';
            }
            
            if (dataType === 'circle' || dataType === 'all') {
                const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
                const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
                const phaseAngle = (2 * Math.PI * phaseR) / phaseM;
                const phaseAngleDeg = (360 * phaseR) / phaseM;
                
                csv += '# Farey Channel Representation - Unit Circle\n';
                csv += '# All residues r/mod for moduli from 1 to m\n';
                csv += `# Phase rotation: ${phaseR}/${phaseM} = ${phaseAngleDeg.toFixed(17)} degrees\n`;
                csv += 'modulus,residue,fraction,angle_degrees,angle_radians,real,imaginary,gcd_value,is_unit,ring_radius\n';
                
                for (let mod = 1; mod <= m; mod++) {
                    const ringRadius = mod / m;
                    
                    for (let r = 0; r < mod; r++) {
                        const gcdVal = gcd(r, mod);
                        const angle = (2 * Math.PI * r) / mod + phaseAngle;
                        const angleDeg = (360 * r) / mod + phaseAngleDeg;
                        const real = Math.cos(angle);
                        const imag = Math.sin(angle);
                        const isUnit = gcdVal === 1 ? 'TRUE' : 'FALSE';
                        const fraction = `${r}/${mod}`;
                        
                        csv += `${mod},${r},${fraction},${angleDeg.toFixed(6)},${angle.toFixed(6)},${real.toFixed(6)},${imag.toFixed(6)},${gcdVal},${isUnit},${ringRadius.toFixed(6)}\n`;
                    }
                }
                csv += '\n';
            }
            
            if (dataType === 'gcd' || dataType === 'all') {
                csv += '# GCD Structure\n';
                csv += '# Pairwise GCD values\n';
                csv += 'a,b,gcd_value\n';
                
                for (let a = 0; a < m; a++) {
                    for (let b = a + 1; b < m; b++) {
                        const g = gcd(a, b);
                        if (g > 0) {
                            csv += `${a},${b},${g}\n`;
                        }
                    }
                }
                csv += '\n';
            }
            
            if (dataType === 'density' || dataType === 'all') {
                csv += '# Coprime Density Analysis\n';
                csv += '# Euler totient function œÜ(n) and density œÜ(n)/n\n';
                csv += 'n,phi_n,density,six_over_pi_squared\n';
                
                const sixOverPiSq = 6 / (Math.PI * Math.PI);
                for (let n = 2; n <= m; n++) {
                    const phi = euler_phi(n);
                    const density = phi / n;
                    csv += `${n},${phi},${density.toFixed(6)},${sixOverPiSq.toFixed(6)}\n`;
                }
            }
            
            // Determine filename
            if (dataType === 'all') {
                filename = `modular_all_data_m${m}.csv`;
            } else {
                filename = `modular_${dataType}_data_m${m}.csv`;
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('Export Complete', `${dataType === 'all' ? 'All' : dataType.charAt(0).toUpperCase() + dataType.slice(1)} data exported as CSV`);
        }

        // Rest of the existing functions remain the same...

        // Initialize
        window.onload = function() {
            updateVisualization();
        };
    </script>
</body>
    </html>
