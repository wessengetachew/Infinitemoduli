<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Arithmetic Explorer - Multi-Canvas Visualization Suite</title>
    <style>
        :root {
            --bg-deep: #0a0e1a;
            --bg-card: #141829;
            --bg-panel: #1a1f35;
            --gold: #FFD700;
            --gold-dim: #B8960A;
            --cyan: #00FFFF;
            --cyan-dim: #008B8B;
            --text-primary: #E8E8E8;
            --text-secondary: #A0A0A0;
            --border: #2a3150;
            --accent-purple: #9F7AEA;
            --accent-green: #48BB78;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 20px;
        }

        .main-container {
            max-width: 2400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, var(--bg-card), var(--bg-panel));
            border-radius: 15px;
            border: 2px solid var(--border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--gold), var(--cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.2em;
            margin-top: 10px;
        }

        .author {
            color: var(--gold-dim);
            margin-top: 15px;
            font-style: italic;
            font-size: 1.1em;
        }

        /* Canvas Grid */
        .viz-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .canvas-panel {
            background: var(--bg-card);
            border-radius: 12px;
            border: 2px solid var(--border);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .canvas-panel:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(255, 215, 0, 0.2);
            border-color: var(--gold-dim);
        }

        .panel-header {
            background: linear-gradient(135deg, var(--bg-panel), var(--bg-card));
            padding: 20px;
            border-bottom: 2px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-size: 1.5em;
            font-weight: 700;
            color: var(--gold);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .panel-subtitle {
            color: var(--cyan-dim);
            font-size: 0.9em;
            margin-top: 5px;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            background: var(--bg-deep);
        }

        .canvas-info {
            padding: 15px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        /* Controls Section */
        .controls-section {
            background: var(--bg-card);
            border-radius: 12px;
            border: 2px solid var(--border);
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .controls-header {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--gold);
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }

        .section-header {
            font-size: 1.3em;
            color: var(--cyan);
            margin: 25px 0 15px 0;
            font-weight: 600;
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-item {
            flex: 1;
            min-width: 250px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-weight: 600;
        }

        .control-value {
            color: var(--gold);
            font-family: 'Courier New', monospace;
            font-weight: 700;
            padding: 4px 12px;
            background: var(--bg-panel);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--bg-panel);
            outline: none;
            -webkit-appearance: none;
            border: 1px solid var(--border);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--gold), var(--cyan));
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--gold), var(--cyan));
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            border: none;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            background: var(--bg-panel);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1em;
            transition: all 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--gold);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        /* Radio and Checkbox Styles */
        .radio-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .radio-option, .checkbox-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: var(--bg-panel);
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .radio-option:hover, .checkbox-option:hover {
            border-color: var(--gold-dim);
            background: var(--bg-card);
        }

        .radio-option input:checked + span,
        .checkbox-option input:checked + span {
            color: var(--gold);
            font-weight: 700;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--gold-dim), var(--gold));
            color: var(--bg-deep);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--cyan-dim), var(--cyan));
            color: var(--bg-deep);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 255, 255, 0.5);
        }

        /* Preset Grid */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }

        .preset-btn {
            padding: 12px;
            background: var(--bg-panel);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-green));
            border-color: var(--gold);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(159, 122, 234, 0.4);
        }

        /* Info Panel */
        .info-panel {
            background: linear-gradient(135deg, var(--bg-panel), var(--bg-card));
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--border);
            margin: 20px 0;
        }

        .info-title {
            font-size: 1.3em;
            color: var(--gold);
            margin-bottom: 15px;
            font-weight: 700;
        }

        .info-content {
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: var(--bg-panel);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid var(--border);
            text-align: center;
        }

        .stat-label {
            color: var(--cyan);
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .stat-value {
            color: var(--gold);
            font-size: 2em;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }

        .stat-details {
            color: var(--text-secondary);
            font-size: 0.85em;
            margin-top: 8px;
            word-wrap: break-word;
        }

        /* Export Section */
        .export-section {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 30px 0;
            padding: 25px;
            background: var(--bg-card);
            border-radius: 12px;
            border: 2px solid var(--border);
        }

        /* Introduction Section */
        .intro-section {
            background: var(--bg-card);
            border-radius: 12px;
            border: 2px solid var(--border);
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .intro-header {
            background: linear-gradient(135deg, var(--bg-panel), var(--bg-card));
            padding: 20px 30px;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 2px solid var(--border);
        }

        .intro-header:hover {
            background: linear-gradient(135deg, var(--bg-card), var(--bg-panel));
        }

        .intro-header h2 {
            color: var(--gold);
            font-size: 1.8em;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #introToggle {
            transition: transform 0.3s;
            display: inline-block;
        }

        #introToggle.collapsed {
            transform: rotate(-90deg);
        }

        .intro-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            padding: 30px;
            overflow-y: auto;
        }

        .intro-content.collapsed {
            max-height: 0;
            padding: 0 30px;
            overflow: hidden;
        }

        .intro-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
        }

        .intro-card {
            background: var(--bg-panel);
            padding: 25px;
            border-radius: 10px;
            border: 2px solid var(--border);
            transition: all 0.3s;
        }

        .intro-card:hover {
            border-color: var(--gold-dim);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.2);
        }

        .intro-card h3 {
            color: var(--cyan);
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid var(--border);
            padding-bottom: 10px;
        }

        .intro-card p {
            color: var(--text-secondary);
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .intro-card p:last-child {
            margin-bottom: 0;
        }

        .intro-card strong {
            color: var(--text-primary);
        }

        .intro-card em {
            color: var(--gold-dim);
            font-style: normal;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 30px;
            border-top: 2px solid var(--border);
            color: var(--text-secondary);
        }

        footer a {
            color: var(--gold);
            text-decoration: none;
            transition: color 0.3s;
        }

        footer a:hover {
            color: var(--cyan);
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .viz-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 900px) {
            .viz-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2em;
            }
        }

        /* Notification */
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--gold), var(--cyan));
            color: var(--bg-deep);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <h1>⟨ Modular Arithmetic Explorer ⟩</h1>
            <div class="subtitle">Multi-Canvas Visualization Suite · Ring Theory · Number Theory</div>
            <div class="author">Wessen Getachew · @7dview</div>
        </header>

        <!-- Introduction Section (Collapsible) -->
        <div class="intro-section">
            <div class="intro-header" onclick="toggleIntro()">
                <h2>
                    <span id="introToggle">▼</span> Introduction & Guide
                </h2>
            </div>
            <div class="intro-content" id="introContent">
                <div class="intro-grid">
                    <div class="intro-card">
                        <h3>What is This Tool?</h3>
                        <p>
                            This interactive visualization suite provides comprehensive exploration of <strong>modular arithmetic</strong> through four synchronized canvases, 
                            each revealing different structural properties of the ring ℤ/mℤ = {0, 1, 2, ..., m-1} with addition and multiplication mod m.
                        </p>
                        <p>
                            <strong>Canvas 1: Multiplication Table</strong> - Complete operation tables with multiple coloring schemes (Rainbow, Divisibility, Zero Divisors, Idempotents). 
                            Features live statistics dashboard showing modulus properties, unit count, density, and quick properties. Includes element inspector for detailed analysis of individual elements.
                            Additional tools: symmetry highlighting, diagonal emphasis, alternate shading, cell opacity control, bold labels, and table transpose.
                        </p>
                        <p>
                            <strong>Canvas 2: Unit Circle - Farey Channels</strong> - Geometric representation with concentric rings for all moduli from 1 to m. 
                            Features global phase rotation (r/m with 17-decimal precision), per-ring rotation control, dyadic power connections for cardioid patterns, 
                            and multiple connection modes. Live statistics track rotation angles and residue layer counts.
                            Point labeling options: none, r, r/m, 2πr/m, -2πr/m. Additional tools: angle markers, fade non-coprime, animation control.
                        </p>
                        <p>
                            <strong>Canvas 3: GCD Structure - 3D Sphere</strong> - Interactive 3D visualization with full 360-degree rotation on both axes, 
                            zoom control (50%-200%), auto-rotate mode, optional grid display, and mouse drag support. Maps GCD relationships to spherical coordinates with depth-sorted rendering. 
                            Live statistics show current rotation angles and zoom level.
                            Point labeling options: none, (a,b) pairs, gcd(a,b) values. Additional filters: coprime-only mode, color by GCD, point size scaling, axis snap views.
                        </p>
                        <p>
                            <strong>Canvas 4: Coprime Density</strong> - Plot of φ(n)/n for all n from 2 to m, with Basel problem reference line (6/π² ≈ 0.6079). 
                            Adjustable point size, optional grid/labels, point connection mode, and prime highlighting. Live statistics display density trends and Basel ratio comparisons.
                            Point labeling options: none, n values, density values, primes only. Unique feature: "Connect Same Densities" draws dashed lines connecting all points 
                            with matching coprime densities (like 1/2, 1/3, etc.) and labels the reduced fractions on the y-axis, revealing the rational structure of totient distributions.
                            Additional tools: trendline, log scale x-axis, y-axis range control, zoom to primes, fit to data.
                        </p>
                        <p>
                            <strong>Global Features:</strong> All canvases include mouse hover tooltips for detailed information, live updating statistics panels, synchronized controls, 
                            and keyboard shortcuts (press H for help). Animation player supports automated progression through moduli (1-1000 range with adjustable speed). 
                            Export system provides 2K/4K/8K resolution options with comprehensive legends, statistical analysis panels, and individual/combined canvas exports. 
                            Mathematical presets include Basel Problem (m=6), Highly Composite (m=60), Prime Fields (m=17), Fibonacci/Mersenne primes, Perfect Numbers, and more.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>Canvas 1: Multiplication Table</h3>
                        <p>
                            <strong>What it shows:</strong> The complete multiplication table a × b (mod m) for all elements.
                            Each cell (i,j) shows the product of row i and column j reduced modulo m.
                        </p>
                        <p>
                            <strong>Table Types:</strong>
                            <br>• Multiplication: Full ring multiplication a × b (mod m)
                            <br>• Cayley (Units): Restricted to invertible elements only
                            <br>• Addition: Addition table a + b (mod m)
                        </p>
                        <p>
                            <strong>Color schemes:</strong>
                            <br>• Rainbow: Color by result value (hue-based spectrum)
                            <br>• Divisibility: Intensity by number of divisors of result
                            <br>• Zero Divisors: Highlights non-zero elements where ab ≡ 0 (mod m)
                            <br>• Idempotents: Elements where a² ≡ a (mod m) in gold
                        </p>
                        <p>
                            <strong>Live Statistics Dashboard:</strong> Real-time display of modulus properties including φ(m) count, density ratio, 
                            units list, zero divisor count, idempotent set, prime test with factorization, previous/next primes, Carmichael lambda, 
                            and group order. Updates instantly as modulus changes.
                        </p>
                        <p>
                            <strong>Element Inspector:</strong> Click any table cell or enter element number to analyze individual elements. 
                            Shows order (for units), inverse calculation, power sequences, generated subgroup, idempotent status, and nilpotent properties. 
                            Includes "Highlight in Table" and "Show Subgroup" buttons for visual exploration.
                        </p>
                        <p>
                            <strong>Key insight:</strong> Patterns reveal ring structure, symmetries, and special elements. Hover over cells for instant 
                            operation details and properties.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>Canvas 2: Unit Circle - Farey Channels</h3>
                        <p>
                            <strong>What it shows:</strong> Comprehensive visualization of all residues r/m for every modulus from 1 to m, 
                            mapped to concentric rings inside the unit circle. Each ring represents a different modulus, with points at 
                            angles ±2πr/m showing both positive and negative rotations. Total of m(m+1)/2 residues displayed.
                        </p>
                        <p>
                            <strong>Global Phase Rotation (r/m):</strong> Control global rotation with fraction r/m, displayed to 17 decimal places 
                            for maximum precision. For example, r=1, m=2 gives 180° rotation; r=1, m=8 gives 45°. This reveals rotational symmetries 
                            in the modular structure. Quick preset buttons available for common fractions (1/2, 1/3, 1/4, 2/3, 1/6, 3/4, 1/8).
                        </p>
                        <p>
                            <strong>Per-Ring Rotation Increment:</strong> Additional rotation control (0-360°) that applies progressively to each ring. 
                            Ring index × increment creates spiral patterns. Can be applied to global phase via checkbox to affect all canvases.
                        </p>
                        <p>
                            <strong>Residue Layers:</strong> Concentric rings from center (m=1, specially marked and larger) to outer edge (m=your_limit). 
                            Ring radius = m/M × maxRadius. Points colored by gcd(r,m): Gold for coprime (gcd=1, units), 
                            Cyan for prime GCD (when enabled), gradient for composite GCD values. Ring labels show modulus values at intervals.
                        </p>
                        <p>
                            <strong>Connection Modes:</strong>
                            <br>• Show Residue Layers: Toggle visibility of all concentric rings
                            <br>• Connect r in Each m: Forms polygons on each ring connecting points with same residue
                            <br>• Connect r to Next mod r: Radial lines showing how residues project through modular hierarchy
                            <br>• Dyadic Powers r×2ⁿ: Creates cardioid patterns by connecting r, 2r, 4r, 8r, 16r... (coprime points only)
                            <br>• Highlight Prime GCD: Cyan coloring for points where gcd(r,m) is prime
                        </p>
                        <p>
                            <strong>Line Thickness Control:</strong> Adjustable slider (0.5-5px) for connection line width to optimize visibility.
                        </p>
                        <p>
                            <strong>Live Statistics:</strong> Real-time display of current phase rotation angle (17 decimals), per-ring increment, 
                            total residue count, and layer information. Updates instantly with any parameter change.
                        </p>
                        <p>
                            <strong>Key insight:</strong> Visualizes the complete modular lattice structure, showing how residue classes 
                            relate across different moduli. Dyadic connections reveal multiplication by 2 patterns (like times table cardioids). 
                            Phase rotation exposes hidden symmetries. The center represents gcd=1 (coprimality), with φ(m) gold points on each ring. 
                            Hover over points for detailed fraction, angle, and GCD information.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>Canvas 3: GCD Structure - 3D Sphere</h3>
                        <p>
                            <strong>What it shows:</strong> Interactive 3D sphere visualization mapping pairs (a,b) to spherical coordinates 
                            based on their GCD value. Points are positioned using spherical coordinates (θ, φ) where θ = 2πa/m (azimuthal) 
                            and φ = πb/m (polar), with radius proportional to gcd(a,b). Creates shells where coprime pairs cluster near surface.
                        </p>
                        <p>
                            <strong>Full 360-Degree Rotation Control:</strong> Two independent sliders control X-axis and Y-axis rotation (0-360°) 
                            with real-time updates. Explore from any angle to reveal hidden structures. Mouse drag support for intuitive rotation 
                            (click and drag to rotate, cursor changes to grabbing hand). Values displayed in degrees with instant visual feedback.
                        </p>
                        <p>
                            <strong>Zoom Control:</strong> Adjust view distance from 50% to 200% for detailed inspection or overview perspective. 
                            Maintains proper depth sorting and point scaling throughout zoom range.
                        </p>
                        <p>
                            <strong>Interactive Features:</strong>
                            <br>• Rotation X/Y: Full 360° control on both axes - explore from any angle, mouse drag enabled
                            <br>• Zoom: Perspective adjustment from 50% to 200% of base size
                            <br>• Show Connections: Draw lines between related GCD pairs for structural analysis
                            <br>• Show Grid: Display latitude/longitude grid with X/Y/Z axes for spatial reference
                            <br>• Auto-Rotate: Continuous animation mode for presentations (rotates on Y-axis)
                            <br>• Reset View: Instantly return to default orientation (45°, 45°, 100%)
                        </p>
                        <p>
                            <strong>3D Mapping Mathematics:</strong> Each pair (a,b) with gcd value g maps to 3D coordinates:
                            x = r·sin(φ)·cos(θ), y = r·sin(φ)·sin(θ), z = r·cos(φ), where r = (g/max_gcd)·radius.
                            Perspective projection with focalLength/(focalLength + z) scaling. Depth sorting ensures proper occlusion. 
                            Point size and opacity scale with depth for realistic 3D effect (back points smaller/dimmer).
                        </p>
                        <p>
                            <strong>Color Coding:</strong> Hue mapped to GCD value - coprime pairs (gcd=1) in gold at surface, 
                            higher GCD values in spectrum from blue to red. Brightness increases for closer points (depth-based lighting).
                        </p>
                        <p>
                            <strong>Live Statistics:</strong> Real-time display of current X-rotation angle, Y-rotation angle, and zoom percentage. 
                            Updates continuously during rotation and zoom operations. Shows whether auto-rotate is active.
                        </p>
                        <p>
                            <strong>Key insight:</strong> The 3D sphere reveals spatial clustering of GCD relationships that aren't 
                            visible in 2D. Coprime pairs (gcd=1, gold) cluster near the surface forming a dense shell. Higher GCD values create concentric 
                            inner shells. Rotation exposes hidden symmetries in the divisibility structure. The spherical topology naturally 
                            represents the periodic nature of modular arithmetic. Hover over points for pair information and GCD details.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>Canvas 4: Coprime Density Analysis</h3>
                        <p>
                            <strong>What it shows:</strong> Complete plot of φ(n)/n for all n from 2 to m, where φ(n) is Euler's totient function 
                            (count of numbers coprime to n). Visualizes how the density of coprime numbers varies across different moduli and 
                            converges toward the Basel problem limit.
                        </p>
                        <p>
                            <strong>Basel Problem Reference Line:</strong> Purple dashed line at 6/π² ≈ 0.6079, representing the limiting probability 
                            that two random integers are coprime. This fundamental constant connects number theory to the Riemann zeta function: 
                            ζ(2) = π²/6, so 1/ζ(2) = 6/π². The plot shows how individual moduli deviate from this asymptotic average.
                        </p>
                        <p>
                            <strong>Visualization Controls:</strong>
                            <br>• Point Size: Adjustable slider (1-10px) for optimal visibility across different data ranges
                            <br>• Show 6/π² Line: Toggle Basel problem reference line on/off
                            <br>• Show Grid: Display background grid for easier value reading
                            <br>• Show Labels: Toggle axis labels and value annotations
                            <br>• Connect Points: Optional line connections between consecutive points to show trend
                        </p>
                        <p>
                            <strong>Data Representation:</strong> Each point represents one modulus n (from 2 to m), plotted at coordinates 
                            (n, φ(n)/n). Prime numbers appear highest (φ(p)/p = (p-1)/p → 1 as p increases). Highly composite numbers with 
                            many small prime factors show lowest densities. The m=1 case is omitted as φ(1)/1 = 1 is trivial.
                        </p>
                        <p>
                            <strong>Color Coding:</strong> The current modulus m appears in gold (larger point), m=1 in green (if shown), 
                            and all other points in cyan. This highlights the current focus while maintaining context of the full range.
                        </p>
                        <p>
                            <strong>Live Statistics:</strong> Real-time display of total data points plotted, current modulus density value, 
                            ratio compared to Basel limit, trend analysis (above/below average), and distance to nearest prime densities. 
                            Updates instantly as modulus changes.
                        </p>
                        <p>
                            <strong>Key insight:</strong> Shows how coprime density varies with m and converges toward 6/π² on average. 
                            Prime moduli have densities approaching 1 (all non-zero elements coprime). Composite moduli with many small 
                            prime divisors have lower densities. The overall trend illustrates a fundamental probabilistic property of integers: 
                            asymptotically, about 60.79% of integer pairs are coprime. Hover over points for exact φ(n), density, and Basel ratio.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>Mathematical Concepts</h3>
                        <p>
                            <strong>φ(m) - Euler's Totient:</strong> Count of units (invertible elements). For prime p, φ(p) = p-1.
                            For prime powers, φ(p^k) = p^k - p^(k-1).
                        </p>
                        <p>
                            <strong>Zero Divisors:</strong> Non-zero elements a where ab ≡ 0 (mod m) for some non-zero b.
                            Present when m is composite. Element a is a zero divisor iff gcd(a,m) > 1.
                        </p>
                        <p>
                            <strong>Idempotents:</strong> Elements satisfying a² ≡ a (mod m). Always includes 0 and 1.
                            By Chinese Remainder Theorem, m = p₁^k₁ × ... × pᵣ^kᵣ has 2^r idempotents.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>Using the Tool</h3>
                        <p>
                            <strong>1. Choose a modulus:</strong> Use slider (2-200) or type directly (up to 1000).
                            Try the preset buttons for mathematically significant values: Basel Problem (m=6), φ(12)=4, Prime Field (m=17), 
                            Highly Composite (m=60), Power of 2 (m=32), Fibonacci Prime (m=89), Mersenne Prime (m=31), Perfect Number (m=28), 
                            Golden Ratio (m≈161), and Ramanujan τ (m=24).
                        </p>
                        <p>
                            <strong>2. Select table type (Canvas 1):</strong>
                            <br>• Multiplication: Full ring multiplication a × b (mod m) - reveals multiplicative structure
                            <br>• Cayley (Units Only): Restricted to invertible elements - shows unit group structure
                            <br>• Addition: Addition table a + b (mod m) - always forms a cyclic group
                            <br>Choose color schemes: Rainbow (by value), Divisibility (by divisor count), Zero Divisors (highlights non-invertible), Idempotents (a² ≡ a).
                        </p>
                        <p>
                            <strong>3. Explore Farey Channels (Canvas 2):</strong>
                            <br>• <em>Phase Rotation:</em> Enter r/m fraction to rotate entire structure (17-decimal precision display). Quick presets: 1/2 (180°), 1/3 (120°), 1/4 (90°), 1/6 (60°), 1/8 (45°).
                            <br>• <em>Per-Ring Rotation:</em> Apply progressive rotation to each ring (0-360°). Creates spiral patterns. Can sync to global phase.
                            <br>• <em>Connection Modes:</em> Toggle different connection patterns - polygons on each ring, radial projections through modular hierarchy, dyadic powers for cardioid patterns.
                            <br>• <em>Point Labels:</em> Choose labeling mode - none, r (residue), r/m (fraction), 2πr/m (positive angle), -2πr/m (negative angle).
                            <br>• <em>Residue Layers:</em> See all moduli from 1 to m simultaneously as concentric rings. Gold = coprime (gcd=1), Cyan = prime GCD, gradient = composite GCD.
                        </p>
                        <p>
                            <strong>4. Navigate 3D GCD Sphere (Canvas 3):</strong>
                            <br>• <em>Mouse Control:</em> Click and drag to rotate sphere in real-time. Full 360° freedom on both axes.
                            <br>• <em>Rotation Sliders:</em> Fine control with X-axis (0-360°) and Y-axis (0-360°) sliders. View from any angle.
                            <br>• <em>Quick Views:</em> Snap buttons for X-axis, Y-axis, Z-axis orthogonal views. Reset button returns to default (45°, 45°).
                            <br>• <em>Zoom:</em> Adjust perspective from 50% to 200% for close-up or overview.
                            <br>• <em>Filters:</em> Coprime-only mode shows just gcd=1 pairs. Color by GCD maps hue to divisibility.
                            <br>• <em>Point Labels:</em> Choose (a,b) pairs or gcd(a,b) values. Auto-hides when cluttered.
                            <br>• <em>Auto-Rotate:</em> Continuous animation for presentations.
                        </p>
                        <p>
                            <strong>5. Analyze Coprime Density (Canvas 4):</strong>
                            <br>• <em>Basel Line:</em> Purple dashed reference at 6/π² ≈ 0.6079 shows asymptotic coprime probability.
                            <br>• <em>Connect Same Densities:</em> Automatic detection and connection of points with matching φ(n)/n values. Draws colored dashed lines and labels reduced fractions (1/2, 1/3, 2/3, etc.) on y-axis. Reveals that all even numbers ≥ 2 have density ≥ 1/2, powers of 2 follow specific patterns, etc.
                            <br>• <em>Point Labels:</em> Choose n values, density values, or primes only. Helps identify specific points.
                            <br>• <em>Y-Axis Control:</em> Manually set min/max range or use "Zoom to Primes" / "Fit to Data" for automatic optimization.
                            <br>• <em>Log Scale X:</em> Switch to logarithmic x-axis for better visualization of large ranges.
                            <br>• <em>Trendline:</em> Linear regression shows overall convergence trend toward Basel limit.
                        </p>
                        <p>
                            <strong>6. Use Element Inspector (Canvas 1):</strong>
                            <br>• Click any cell in multiplication table or type element number directly.
                            <br>• View: order, unit status, inverse (if exists), power sequence, generated subgroup.
                            <br>• For non-units: shows zero divisor status, idempotent property, nilpotent detection.
                            <br>• Buttons: "Highlight in Table" emphasizes element in grid, "Show Subgroup" displays generated subgroup.
                        </p>
                        <p>
                            <strong>7. Animation Player:</strong>
                            <br>• Set start/end modulus range (e.g., 1→30, 1→100, 1→1000).
                            <br>• Adjust speed: 50ms to 2000ms per step (default 200ms).
                            <br>• Quick range buttons: 1→30, 1→60, 1→100, 1→1000.
                            <br>• Controls: Play ▶, Pause ⏸, Stop ⏹. Progress tracker shows current position.
                            <br>• All four canvases update simultaneously during animation.
                        </p>
                        <p>
                            <strong>8. Keyboard Shortcuts:</strong> Press <strong>H</strong> to show full list.
                            <br>• Arrow keys: ←/→ change modulus ±1, ↑/↓ change modulus ±10
                            <br>• Space: Play/Pause animation
                            <br>• R: Reset all views to defaults
                            <br>• E: Export all canvases
                            <br>• Esc: Hide keyboard help
                        </p>
                        <p>
                            <strong>9. Export Options:</strong>
                            <br>• Resolution: Choose 2K (2048px), 4K (3840px), or 8K (7680px) before exporting.
                            <br>• Individual Canvas: PNG with title, subtitle, metrics, and comprehensive legend panel.
                            <br>• All 4 Canvases: 2×2 grid layout with titles and key metrics on each panel.
                            <br>• Full Analysis Export: All 4 canvases + extensive statistical analysis panel showing modulus properties, unit group details, zero divisor structure, idempotent analysis, GCD distribution, Basel comparisons, ring classification, and canvas-specific metrics.
                            <br>• CSV Data: Export multiplication table data, circle canvas residue data (all layers with GCD), GCD pair data, density analysis data, or combined "all data" CSV with everything.
                        </p>
                    </div>

                    <div class="intro-card">
                        <h3>Interesting Examples</h3>
                        <p>
                            <strong>m = 6 (Basel Problem):</strong> φ(6) = 2. Only 1 and 5 are units (coprime to 6 = 2×3). 
                            Related to ζ(2) = π²/6 and the fundamental coprime probability 6/π² ≈ 0.6079. 
                            Try phase r=1, m=6 for 60° rotation showing perfect 6-fold symmetry. 
                            Density plot shows how 6/π² emerges as the average. Zero divisors: {2, 3, 4} due to factorization.
                            Idempotents: {0, 1, 3, 4} (2² = 4 total, as predicted by Chinese Remainder Theorem for 2×3).
                        </p>
                        <p>
                            <strong>m = 12:</strong> φ(12) = 4. Units are {1, 5, 7, 11}. Rich structure with 12 = 2²×3.
                            Idempotents: {0, 1, 4, 9} - four idempotents from two prime factors (2² = 4).
                            Enable "Connect r in Each m" to see beautiful dodecagonal (12-gon) patterns in Farey channels. 
                            Phase r=1, m=2 (180°) reveals binary palindrome structure in multiplication table.
                            Density: 4/12 = 1/3 ≈ 0.333, which is 54.8% of Basel limit. Many zero divisors due to composite structure.
                            Element Inspector: Try inspecting 5 (order 2: 5² ≡ 1), or 4 (idempotent: 4² ≡ 4).
                        </p>
                        <p>
                            <strong>m = 17 (Prime Field):</strong> φ(17) = 16. All non-zero elements {1,2,...,16} are units. 
                            Forms a field - no zero divisors, no nilpotents. Only trivial idempotents {0, 1}.
                            Farey channels show perfect symmetry with 16 coprime points (all gold) on outer ring.
                            Density: 16/17 ≈ 0.941, which is 154.8% of Basel limit - primes maximize coprime density.
                            Multiplication table in "Rainbow" mode shows complete cyclic structure.
                            3D GCD sphere: All pairs are coprime, clustering on outer shell surface.
                            Primitive roots exist: 3 is a generator with order 16 (inspect element 3 to see full power sequence).
                        </p>
                        <p>
                            <strong>m = 60 (Highly Composite):</strong> φ(60) = 16. Factorization: 60 = 2²×3×5 (three distinct primes).
                            Rich divisibility structure with many zero divisors. Idempotents: 2³ = 8 total (from three prime factors).
                            Enable "Dyadic Powers r×2ⁿ" in Farey channels to see stunning cardioid patterns emerging from doubling.
                            These patterns are identical to times-table circle art - connecting 1→2→4→8→16→32→4... (mod 60).
                            Density: 16/60 ≈ 0.267 (43.9% of Basel limit). "Connect Same Densities" reveals many points at 1/2, 1/3, 2/5, etc.
                            Perfect for exploring: 60 divides evenly into many parts (excellent for angles, time).
                        </p>
                        <p>
                            <strong>m = 100 (Dyadic Cardioid Demo):</strong> Set m=100, enable "Dyadic Powers r×2ⁿ" in Canvas 2.
                            Watch how multiplication by powers of 2 creates beautiful cardioid/nephroid curves.
                            Each starting point r traces its own curve: r → 2r → 4r → 8r → 16r → ... (mod 100).
                            Only coprime points participate (gcd(r,100)=1), creating gaps in the pattern.
                            This connects modular arithmetic to classic mathematical art visualizations.
                            φ(100) = 40 (since 100 = 2²×5²), so 40 golden points on outer ring generate 40 cardioid traces.
                        </p>
                        <p>
                            <strong>Phase Rotation Exploration:</strong> 
                            <br>• m=8 with phase r=1, m=8 (45°): Perfect octagonal symmetry, 8-fold rotational invariance.
                            <br>• m=12 with phase r=1, m=3 (120°): Triangular symmetry, reveals 3-fold structure in 12.
                            <br>• m=12 with phase r=1, m=4 (90°): Square symmetry, emphasizes factors of 4.
                            <br>• m=360 with phase r=1, m=360 (1°): Explore circle with degree precision.
                            <br>The 17-decimal angle display shows exact rotation for reproducing visualizations.
                        </p>
                        <p>
                            <strong>Density Fraction Lines (Canvas 4):</strong> Enable "Connect Same Densities" and observe:
                            <br>• All even numbers n ≥ 2: horizontal line at density = 1/2 (exactly half are coprime).
                            <br>• Powers of 2 (4, 8, 16, 32, ...): line at density = 1/2 (from 2^(k-1) coprime to 2^k).
                            <br>• Multiples of 3 only (9, 27, 81): line at density = 2/3.
                            <br>• Numbers of form 2×3^k: line at density = 1/3.
                            <br>Patterns reveal: φ(n)/n = product over primes p|n of (1 - 1/p).
                            <br>Try m=60 or m=100 to see multiple fraction lines clearly labeled.
                        </p>
                        <p>
                            <strong>Element Inspector Deep Dives:</strong>
                            <br>• m=15, inspect element 6: Zero divisor (6×10 ≡ 0), not idempotent, not nilpotent.
                            <br>• m=8, inspect element 2: Nilpotent! 2³ = 8 ≡ 0 (mod 8). Generates {2, 4, 0}.
                            <br>• m=21, inspect element 4: Idempotent (4² ≡ 16 ≡ 4 mod 21). Not a unit.
                            <br>• m=13, inspect element 2: Primitive root - generates all non-zero elements. Order = 12 = φ(13).
                            <br>Click cells in multiplication table to instantly inspect products.
                        </p>
                        <p>
                            <strong>3D GCD Sphere Rotations:</strong>
                            <br>• Default view (45°, 45°): Balanced perspective showing shell structure.
                            <br>• Top view (0°, 0°): Looking down Z-axis, see azimuthal distribution.
                            <br>• Side view (90°, 0°): Looking from Y-axis, see polar angle distribution.
                            <br>• Enable "Coprime Only" filter to see just the outer shell of gcd=1 pairs.
                            <br>• Enable "Show Grid" for spatial reference with lat/lon lines and XYZ axes.
                            <br>• Try m=30 or m=60 for rich 3D structure with multiple GCD shells.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Multi-Canvas Visualization Grid -->
        <div class="viz-grid">
            <!-- Canvas 1: Main Multiplication Grid -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">⊗ Multiplication Table</div>
                        <div class="panel-subtitle">Ring ℤ/mℤ · Color-coded Structure</div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" onclick="exportCanvas('grid')" style="padding: 8px 15px; font-size: 0.9em;">PNG</button>
                        <button class="btn btn-secondary" onclick="exportData('grid')" style="padding: 8px 15px; font-size: 0.9em;">CSV</button>
                    </div>
                </div>
                <canvas id="gridCanvas" width="800" height="800"></canvas>
                <div class="canvas-info" id="gridInfo">
                    <!-- Independent Mode Toggle -->
                    <div style="margin-bottom: 15px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="gridIndependent" onchange="toggleCanvasMode('grid')">
                            <span style="color: var(--gold); font-weight: 700; font-size: 1.1em;">🔓 Independent Mode</span>
                        </label>
                        <div id="gridIndependentControls" style="display: none; margin-top: 15px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Canvas Modulus (m):</label>
                            <input type="range" id="gridModulusSlider" min="2" max="200" value="12" 
                                   style="width: 100%;" oninput="document.getElementById('gridModulusValue').value = this.value; updateIndependentCanvas('grid')">
                            <input type="number" id="gridModulusValue" min="2" max="1000" value="12" 
                                   style="width: 100%; margin-top: 8px;"
                                   onchange="document.getElementById('gridModulusSlider').value = Math.min(this.value, 200); updateIndependentCanvas('grid')">
                        </div>
                    </div>
                    
                    <!-- Collapsible Controls -->
                    <div style="background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border); margin-bottom: 15px; overflow: hidden;">
                        <div onclick="toggleCanvasControls('grid')" style="padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(135deg, var(--bg-card), var(--bg-panel)); transition: all 0.3s;">
                            <span style="color: var(--gold); font-weight: 700; font-size: 1.1em;">⚙️ Canvas Controls & Settings</span>
                            <span id="gridToggleIcon" style="color: var(--cyan); font-size: 1.3em; transition: transform 0.3s;">▼</span>
                        </div>
                        <div id="gridControls" style="max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out;">
                            <div style="padding: 20px;">
                    
                    <div style="margin-bottom: 20px;">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Table Type:</label>
                        <div class="radio-group" style="gap: 8px;">
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="tableTypeCanvas1" value="multiplication" checked onchange="canvasIndependentStates.grid.active ? updateIndependentCanvas('grid') : updateVisualization()">
                                <span>Multiplication</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="tableTypeCanvas1" value="cayley" onchange="canvasIndependentStates.grid.active ? updateIndependentCanvas('grid') : updateVisualization()">
                                <span>Cayley (Units)</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="tableTypeCanvas1" value="addition" onchange="canvasIndependentStates.grid.active ? updateIndependentCanvas('grid') : updateVisualization()">
                                <span>Addition</span>
                            </label>
                        </div>
                    </div>
                    <div>
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Color Scheme:</label>
                        <div class="radio-group" style="gap: 8px;">
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="colorSchemeCanvas1" value="rainbow" checked onchange="updateVisualization()">
                                <span>Rainbow</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="colorSchemeCanvas1" value="divisibility" onchange="updateVisualization()">
                                <span>Divisibility</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="colorSchemeCanvas1" value="zeroDivisors" onchange="updateVisualization()">
                                <span>Zero Divisors</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="colorSchemeCanvas1" value="idempotents" onchange="updateVisualization()">
                                <span>Idempotents</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Additional Grid Controls -->
                    <div style="margin-top: 20px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 10px;">Advanced Display Options:</label>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <label style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-card); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                                <input type="checkbox" id="showTableSymmetry" onchange="updateVisualization()">
                                <span style="color: var(--text-primary);">Highlight Symmetry</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-card); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                                <input type="checkbox" id="showDiagonal" onchange="updateVisualization()">
                                <span style="color: var(--text-primary);">Highlight Diagonal</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-card); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                                <input type="checkbox" id="alternateShading" onchange="updateVisualization()">
                                <span style="color: var(--text-primary);">Alternate Shading</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-card); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                                <input type="checkbox" id="boldLabels" onchange="updateVisualization()">
                                <span style="color: var(--text-primary);">Bold Labels</span>
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Cell Opacity:</label>
                        <input type="range" id="cellOpacity" min="0.3" max="1" step="0.1" value="1" 
                               style="width: 100%;" oninput="updateVisualization(); document.getElementById('cellOpacityValue').textContent = Math.round(this.value * 100) + '%'">
                        <span id="cellOpacityValue" style="color: var(--gold); font-family: monospace;">100%</span>
                    </div>
                    
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="transposeTable()" style="padding: 10px 20px;">Transpose Table</button>
                        <button class="btn btn-secondary" onclick="compareWithAddition()" style="padding: 10px 20px;">Compare with Addition</button>
                    </div>
                    
                    
                    <!-- Live Statistics Dashboard -->
                    <div style="margin-top: 25px; padding: 20px; background: linear-gradient(135deg, var(--bg-panel), var(--bg-card)); border-radius: 10px; border: 2px solid var(--border);">
                        <h3 style="color: var(--gold); font-size: 1.3em; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            Live Statistics Dashboard
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Modulus</div>
                                <div id="liveStatModulus" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">12</div>
                            </div>
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">φ(m) Units</div>
                                <div id="liveStatPhi" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">4</div>
                            </div>
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Density</div>
                                <div id="liveStatDensity" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">0.333</div>
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-deep); padding: 15px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 15px;">
                            <div style="color: var(--accent-purple); font-weight: 600; margin-bottom: 10px;">Quick Properties:</div>
                            <div id="liveStatProperties" style="color: var(--text-secondary); line-height: 1.8; font-size: 0.95em;">
                                • Units: {1, 5, 7, 11}<br>
                                • Zero Divisors: 7 elements<br>
                                • Idempotents: {0, 1, 4, 9}<br>
                                • Prime Test: Composite (2² × 3)
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-deep); padding: 15px; border-radius: 8px; border: 1px solid var(--border);">
                            <div style="color: var(--accent-green); font-weight: 600; margin-bottom: 10px;">Related Numbers:</div>
                            <div id="liveStatRelated" style="color: var(--text-secondary); line-height: 1.8; font-size: 0.95em;">
                                • Previous Prime: 11 | Next Prime: 13<br>
                                • Carmichael λ(12): 2<br>
                                • Group Order: 4
                            </div>
                        </div>
                    </div>
                    
                    <!-- Element Inspector -->
                    <div style="margin-top: 25px; padding: 20px; background: linear-gradient(135deg, var(--bg-card), var(--bg-panel)); border-radius: 10px; border: 2px solid var(--border);">
                        <h3 style="color: var(--cyan); font-size: 1.3em; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            Element Inspector
                        </h3>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="color: var(--text-primary); font-weight: 600; display: block; margin-bottom: 8px;">
                                Select Element (click table or type):
                            </label>
                            <input type="number" id="inspectorElement" min="0" value="5" 
                                   style="width: 100%; padding: 12px; background: var(--bg-deep); border: 2px solid var(--border); border-radius: 8px; color: var(--gold); font-size: 1.2em; font-weight: 700; font-family: 'Courier New', monospace;"
                                   onchange="updateElementInspector()">
                        </div>
                        
                        <div id="inspectorContent" style="background: var(--bg-deep); padding: 15px; border-radius: 8px; border: 1px solid var(--border);">
                            <div style="color: var(--gold); font-size: 1.2em; font-weight: 700; margin-bottom: 12px;">
                                Properties of <span id="inspectorElementTitle">5</span> (mod <span id="inspectorModulus">12</span>):
                            </div>
                            <div id="inspectorDetails" style="color: var(--text-secondary); line-height: 2; font-size: 0.95em;">
                                • <strong style="color: var(--text-primary);">Order:</strong> <span style="color: var(--cyan);">2</span> (5² ≡ 1)<br>
                                • <strong style="color: var(--text-primary);">Unit:</strong> <span style="color: var(--accent-green);">✓ Yes</span> (gcd(5,12)=1)<br>
                                • <strong style="color: var(--text-primary);">Inverse:</strong> <span style="color: var(--gold);">5⁻¹ ≡ 5</span><br>
                                • <strong style="color: var(--text-primary);">Powers:</strong> 5¹=5, 5²=1<br>
                                • <strong style="color: var(--text-primary);">Generates:</strong> {1, 5}
                            </div>
                        </div>
                        
                        <div style="margin-top: 15px; display: flex; gap: 10px;">
                            <button class="btn btn-secondary" onclick="highlightElementInTable()" style="flex: 1; padding: 10px;">
                                Highlight in Table
                            </button>
                            <button class="btn btn-secondary" onclick="showSubgroupGenerated()" style="flex: 1; padding: 10px;">
                                Show Subgroup
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Canvas 2: Unit Circle Representation -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">○ Unit Circle - Farey Channels</div>
                        <div class="panel-subtitle">Modular Residue Channels · Phase Rotation · Dyadic Lifting</div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" onclick="exportCanvas('circle')" style="padding: 8px 15px; font-size: 0.9em;">PNG</button>
                        <button class="btn btn-secondary" onclick="exportData('circle')" style="padding: 8px 15px; font-size: 0.9em;">CSV</button>
                    </div>
                </div>
                <canvas id="circleCanvas" width="800" height="800"></canvas>
                <div class="canvas-info" id="circleInfo">
                    <!-- Independent Mode Toggle -->
                    <div style="margin-bottom: 15px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="circleIndependent" onchange="toggleCanvasMode('circle')">
                            <span style="color: var(--gold); font-weight: 700; font-size: 1.1em;">🔓 Independent Mode</span>
                        </label>
                        <div id="circleIndependentControls" style="display: none; margin-top: 15px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Canvas Modulus (m):</label>
                            <input type="range" id="circleModulusSlider" min="2" max="200" value="12" 
                                   style="width: 100%;" oninput="document.getElementById('circleModulusValue').value = this.value; updateIndependentCanvas('circle')">
                            <input type="number" id="circleModulusValue" min="2" max="1000" value="12" 
                                   style="width: 100%; margin-top: 8px;"
                                   onchange="document.getElementById('circleModulusSlider').value = Math.min(this.value, 200); updateIndependentCanvas('circle')">
                        </div>
                    </div>
                    
                    <!-- Collapsible Controls -->
                    <div style="background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border); margin-bottom: 15px; overflow: hidden;">
                        <div onclick="toggleCanvasControls('circle')" style="padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(135deg, var(--bg-card), var(--bg-panel)); transition: all 0.3s;">
                            <span style="color: var(--gold); font-weight: 700; font-size: 1.1em;">⚙️ Canvas Controls & Settings</span>
                            <span id="circleToggleIcon" style="color: var(--cyan); font-size: 1.3em; transition: transform 0.3s;">▼</span>
                        </div>
                        <div id="circleControls" style="max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out;">
                            <div style="padding: 20px;">
                    
                    <!-- Live Statistics Dashboard for Circle Canvas -->
                    <div style="margin-bottom: 25px; padding: 20px; background: linear-gradient(135deg, var(--bg-panel), var(--bg-card)); border-radius: 10px; border: 2px solid var(--border);">
                        <h3 style="color: var(--gold); font-size: 1.3em; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            Live Statistics - Farey Channels
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Total Residues</div>
                                <div id="liveCircleTotalResidues" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">78</div>
                            </div>
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Phase Angle</div>
                                <div id="liveCirclePhaseAngle" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">0.00000°</div>
                            </div>
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Ring Increment</div>
                                <div id="liveCircleRingRotation" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">0°</div>
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-deep); padding: 15px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 15px;">
                            <div style="color: var(--accent-purple); font-weight: 600; margin-bottom: 10px;">Rotation Settings:</div>
                            <div id="liveCircleRotationInfo" style="color: var(--text-secondary); line-height: 1.8; font-size: 0.95em;">
                                • Phase: 0/1 (0.00000000000000000°)<br>
                                • Per-Ring: 0° increment<br>
                                • Layers: 1 to 12 (visible)<br>
                                • Connection Mode: None active
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-deep); padding: 15px; border-radius: 8px; border: 1px solid var(--border);">
                            <div style="color: var(--accent-green); font-weight: 600; margin-bottom: 10px;">Layer Distribution:</div>
                            <div id="liveCircleLayerInfo" style="color: var(--text-secondary); line-height: 1.8; font-size: 0.95em;">
                                • Coprime Points: 28 (gold)<br>
                                • Prime GCD Points: 0 (cyan)<br>
                                • Composite GCD: 50<br>
                                • Sum Formula: m(m+1)/2
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
                        <div style="flex: 1; min-width: 250px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Global Phase Rotation (r/m):
                            </label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="number" id="phaseNumerator" value="0" min="0" 
                                       style="width: 80px; padding: 8px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 6px; color: var(--text-primary);"
                                       onchange="updateCircleVisualization()">
                                <span style="color: var(--gold); font-size: 1.3em; font-weight: 700;">/</span>
                                <input type="number" id="phaseDenominator" value="1" min="1" 
                                       style="width: 80px; padding: 8px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 6px; color: var(--text-primary);"
                                       onchange="updateCircleVisualization()">
                            </div>
                        </div>
                        <div style="flex: 1; min-width: 250px;">
                            <label style="color: var(--gold); font-weight: 600; display: block; margin-bottom: 5px;">
                                Angle (17 decimals):
                            </label>
                            <div id="phaseAngleDisplay" style="font-family: 'Courier New', monospace; color: var(--text-primary); font-size: 1.1em; background: var(--bg-panel); padding: 8px; border-radius: 6px; border: 1px solid var(--border);">
                                0.00000000000000000°
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
                        <div style="flex: 1; min-width: 250px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Per-Ring Rotation Increment (degrees):
                            </label>
                            <input type="range" id="ringRotation" min="0" max="360" step="1" value="0" 
                                   style="width: 100%;" oninput="updateCircleVisualization(); document.getElementById('ringRotationValue').textContent = this.value + '°'">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 5px;">
                                <span id="ringRotationValue" style="color: var(--gold); font-family: monospace; font-size: 1.1em;">0°</span>
                                <span style="color: var(--text-secondary); font-size: 0.85em;">Each ring rotates by index × increment</span>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg-panel); padding: 15px; border-radius: 8px; border: 2px solid var(--border); margin-bottom: 20px;">
                        <label style="color: var(--accent-purple); font-weight: 600; display: block; margin-bottom: 10px;">
                            k/d Fraction Presets (Align Fractional Positions):
                        </label>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px;">
                            <button class="preset-btn" onclick="applyFractionPreset(1, 2)" style="padding: 6px 12px; font-size: 0.9em;">1/2 (180°)</button>
                            <button class="preset-btn" onclick="applyFractionPreset(1, 3)" style="padding: 6px 12px; font-size: 0.9em;">1/3 (120°)</button>
                            <button class="preset-btn" onclick="applyFractionPreset(1, 4)" style="padding: 6px 12px; font-size: 0.9em;">1/4 (90°)</button>
                            <button class="preset-btn" onclick="applyFractionPreset(2, 3)" style="padding: 6px 12px; font-size: 0.9em;">2/3 (240°)</button>
                            <button class="preset-btn" onclick="applyFractionPreset(1, 6)" style="padding: 6px 12px; font-size: 0.9em;">1/6 (60°)</button>
                            <button class="preset-btn" onclick="applyFractionPreset(3, 4)" style="padding: 6px 12px; font-size: 0.9em;">3/4 (270°)</button>
                            <button class="preset-btn" onclick="applyFractionPreset(1, 8)" style="padding: 6px 12px; font-size: 0.9em;">1/8 (45°)</button>
                            <button class="preset-btn" onclick="applyFractionPreset(0, 1)" style="padding: 6px 12px; font-size: 0.9em;">Reset (0°)</button>
                        </div>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-card); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="applyToAllCanvases" onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary); font-weight: 600;">Apply rotation to Global Phase (affects all canvases)</span>
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                            Connection Line Thickness:
                        </label>
                        <input type="range" id="lineThickness" min="0.5" max="5" step="0.5" value="1.5" 
                               style="width: 100%;" oninput="updateCircleVisualization(); document.getElementById('lineThicknessValue').textContent = this.value + 'px'">
                        <span id="lineThicknessValue" style="color: var(--gold); font-family: monospace;">1.5px</span>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showResidueLayers" checked onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Show Residue Layers</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="connectByR" checked onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Connect r in Each m</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="connectToNextMod" checked onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Connect r to Next mod r</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="connectDyadicPowers" onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Dyadic Powers r×2ⁿ</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="highlightPrimeGCD" checked onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Highlight Prime GCD Channels</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showRingLabels" checked onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Show Ring Labels</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showAngleMarkers" onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Show Angle Markers</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="fadeNonCoprime" onchange="updateCircleVisualization()">
                            <span style="color: var(--text-primary);">Fade Non-Coprime</span>
                        </label>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Point Labeling Mode:</label>
                        <div class="radio-group" style="gap: 8px;">
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="circleLabelMode" value="none" checked onchange="updateCircleVisualization()">
                                <span>None</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="circleLabelMode" value="r" onchange="updateCircleVisualization()">
                                <span>r</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="circleLabelMode" value="fraction" onchange="updateCircleVisualization()">
                                <span>r/m</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="circleLabelMode" value="theta" onchange="updateCircleVisualization()">
                                <span>2πr/m</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="circleLabelMode" value="thetaNeg" onchange="updateCircleVisualization()">
                                <span>-2πr/m</span>
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Point Size Adjustment:</label>
                        <input type="range" id="circlePointSize" min="2" max="12" step="1" value="4" 
                               style="width: 100%;" oninput="updateCircleVisualization(); document.getElementById('circlePointSizeValue').textContent = this.value + 'px'">
                        <span id="circlePointSizeValue" style="color: var(--gold); font-family: monospace;">4px</span>
                    </div>
                    
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="toggleCircleAnimation()" id="circleAnimBtn" style="padding: 10px 20px;">Animate Rotation</button>
                        <button class="btn btn-secondary" onclick="resetCircleView()" style="padding: 10px 20px;">Reset View</button>
                        <button class="btn btn-secondary" onclick="highlightCoprimeRings()" style="padding: 10px 20px;">Highlight Coprime Rings</button>
                    </div>
                </div>
            </div>
        </div>
                </div>
            </div>

            <!-- Canvas 3: GCD Structure 3D Sphere -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">⊚ GCD Structure - 3D Sphere</div>
                        <div class="panel-subtitle">Interactive 360° View · Coprimality Network</div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" onclick="exportCanvas('gcd')" style="padding: 8px 15px; font-size: 0.9em;">PNG</button>
                        <button class="btn btn-secondary" onclick="exportData('gcd')" style="padding: 8px 15px; font-size: 0.9em;">CSV</button>
                    </div>
                </div>
                <canvas id="gcdCanvas" width="800" height="800"></canvas>
                <div class="canvas-info" id="gcdInfo">
                    <!-- Independent Mode Toggle -->
                    <div style="margin-bottom: 15px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="gcdIndependent" onchange="toggleCanvasMode('gcd')">
                            <span style="color: var(--gold); font-weight: 700; font-size: 1.1em;">🔓 Independent Mode</span>
                        </label>
                        <div id="gcdIndependentControls" style="display: none; margin-top: 15px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Canvas Modulus (m):</label>
                            <input type="range" id="gcdModulusSlider" min="2" max="200" value="12" 
                                   style="width: 100%;" oninput="document.getElementById('gcdModulusValue').value = this.value; updateIndependentCanvas('gcd')">
                            <input type="number" id="gcdModulusValue" min="2" max="1000" value="12" 
                                   style="width: 100%; margin-top: 8px;"
                                   onchange="document.getElementById('gcdModulusSlider').value = Math.min(this.value, 200); updateIndependentCanvas('gcd')">
                        </div>
                    </div>
                    
                    <!-- Collapsible Controls -->
                    <div style="background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border); margin-bottom: 15px; overflow: hidden;">
                        <div onclick="toggleCanvasControls('gcd')" style="padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(135deg, var(--bg-card), var(--bg-panel)); transition: all 0.3s;">
                            <span style="color: var(--gold); font-weight: 700; font-size: 1.1em;">⚙️ Canvas Controls & Settings</span>
                            <span id="gcdToggleIcon" style="color: var(--cyan); font-size: 1.3em; transition: transform 0.3s;">▼</span>
                        </div>
                        <div id="gcdControls" style="max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out;">
                    
                    <!-- Live Statistics Dashboard for GCD Canvas -->
                    <div style="margin-bottom: 25px; padding: 20px; background: linear-gradient(135deg, var(--bg-panel), var(--bg-card)); border-radius: 10px; border: 2px solid var(--border);">
                        <h3 style="color: var(--gold); font-size: 1.3em; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            Live Statistics - 3D Sphere View
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">X-Rotation</div>
                                <div id="liveGCDRotX" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">45°</div>
                            </div>
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Y-Rotation</div>
                                <div id="liveGCDRotY" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">45°</div>
                            </div>
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Zoom Level</div>
                                <div id="liveGCDZoom" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">100%</div>
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-deep); padding: 15px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 15px;">
                            <div style="color: var(--accent-purple); font-weight: 600; margin-bottom: 10px;">View Settings:</div>
                            <div id="liveGCDViewInfo" style="color: var(--text-secondary); line-height: 1.8; font-size: 0.95em;">
                                • Rotation: 45° × 45°<br>
                                • Perspective: 100% base<br>
                                • Auto-Rotate: Inactive<br>
                                • Mouse Drag: Enabled
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-deep); padding: 15px; border-radius: 8px; border: 1px solid var(--border);">
                            <div style="color: var(--accent-green); font-weight: 600; margin-bottom: 10px;">GCD Statistics:</div>
                            <div id="liveGCDPairInfo" style="color: var(--text-secondary); line-height: 1.8; font-size: 0.95em;">
                                • Total Pairs: 66<br>
                                • Coprime Pairs: 28 (42.4%)<br>
                                • Max GCD: 6<br>
                                • Depth Sorting: Active
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: center; margin-bottom: 15px;">
                        <div style="flex: 1; min-width: 200px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Rotation X-axis:
                            </label>
                            <input type="range" id="rotationX" min="0" max="360" value="45" 
                                   style="width: 100%;" oninput="updateGCDVisualization()">
                            <span id="rotXValue" style="color: var(--gold); font-family: monospace;">45°</span>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Rotation Y-axis:
                            </label>
                            <input type="range" id="rotationY" min="0" max="360" value="45" 
                                   style="width: 100%;" oninput="updateGCDVisualization()">
                            <span id="rotYValue" style="color: var(--gold); font-family: monospace;">45°</span>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Zoom:
                            </label>
                            <input type="range" id="zoomLevel" min="50" max="200" value="100" 
                                   style="width: 100%;" oninput="updateGCDVisualization()">
                            <span id="zoomValue" style="color: var(--gold); font-family: monospace;">100%</span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="show3DConnections" checked onchange="updateGCDVisualization()">
                            <span style="color: var(--text-primary);">Show Connections</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showGCDSphereGrid" onchange="updateGCDVisualization()">
                            <span style="color: var(--text-primary);">Show Grid</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="autoRotate" onchange="toggleAutoRotate()">
                            <span style="color: var(--text-primary);">Auto-Rotate</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showCoprimeOnly" onchange="updateGCDVisualization()">
                            <span style="color: var(--text-primary);">Coprime Only</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="colorByGCDValue" checked onchange="updateGCDVisualization()">
                            <span style="color: var(--text-primary);">Color by GCD</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showGCDLabels" onchange="updateGCDVisualization()">
                            <span style="color: var(--text-primary);">Show GCD Labels</span>
                        </label>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Point Labeling Mode:</label>
                        <div class="radio-group" style="gap: 8px;">
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="gcdLabelMode" value="none" checked onchange="updateGCDVisualization()">
                                <span>None</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="gcdLabelMode" value="pair" onchange="updateGCDVisualization()">
                                <span>(a,b)</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="gcdLabelMode" value="gcd" onchange="updateGCDVisualization()">
                                <span>gcd(a,b)</span>
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Point Size Scale:</label>
                        <input type="range" id="gcdPointSize" min="0.5" max="5" step="0.5" value="2" 
                               style="width: 100%;" oninput="updateGCDVisualization(); document.getElementById('gcdPointSizeValue').textContent = this.value + 'x'">
                        <span id="gcdPointSizeValue" style="color: var(--gold); font-family: monospace;">2x</span>
                    </div>
                    
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="resetGCD3DView()" style="padding: 10px 20px;">Reset View</button>
                        <button class="btn btn-secondary" onclick="snapToAxis('x')" style="padding: 10px 20px;">View X-Axis</button>
                        <button class="btn btn-secondary" onclick="snapToAxis('y')" style="padding: 10px 20px;">View Y-Axis</button>
                        <button class="btn btn-secondary" onclick="snapToAxis('z')" style="padding: 10px 20px;">View Z-Axis</button>
                    </div>
                            
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Canvas 4: Coprime Density -->
            <div class="canvas-panel">
                <div class="panel-header">
                    <div>
                        <div class="panel-title">◬ Coprime Density</div>
                        <div class="panel-subtitle">φ(m)/m Analysis</div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" onclick="exportCanvas('density')" style="padding: 8px 15px; font-size: 0.9em;">PNG</button>
                        <button class="btn btn-secondary" onclick="exportData('density')" style="padding: 8px 15px; font-size: 0.9em;">CSV</button>
                    </div>
                </div>
                <canvas id="densityCanvas" width="800" height="800"></canvas>
                <div class="canvas-info" id="densityInfo">
                    <!-- Independent Mode Toggle -->
                    <div style="margin-bottom: 15px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="densityIndependent" onchange="toggleCanvasMode('density')">
                            <span style="color: var(--gold); font-weight: 700; font-size: 1.1em;">🔓 Independent Mode</span>
                        </label>
                        <div id="densityIndependentControls" style="display: none; margin-top: 15px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Data Range (n):</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <div style="flex: 1;">
                                    <label style="color: var(--text-secondary); font-size: 0.9em;">Start:</label>
                                    <input type="number" id="densityStartValue" min="1" max="1000" value="1" 
                                           style="width: 100%;" onchange="updateIndependentCanvas('density')">
                                </div>
                                <div style="flex: 1;">
                                    <label style="color: var(--text-secondary); font-size: 0.9em;">End:</label>
                                    <input type="number" id="densityEndValue" min="2" max="1000" value="100" 
                                           style="width: 100%;" onchange="updateIndependentCanvas('density')">
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap;">
                                <button class="preset-btn" onclick="setDensityRange(1, 50)" style="flex: 1; padding: 8px;">1→50</button>
                                <button class="preset-btn" onclick="setDensityRange(1, 100)" style="flex: 1; padding: 8px;">1→100</button>
                                <button class="preset-btn" onclick="setDensityRange(1, 500)" style="flex: 1; padding: 8px;">1→500</button>
                                <button class="preset-btn" onclick="setDensityRange(1, 1000)" style="flex: 1; padding: 8px;">1→1000</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Collapsible Controls -->
                    <div style="background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border); margin-bottom: 15px; overflow: hidden;">
                        <div onclick="toggleCanvasControls('density')" style="padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(135deg, var(--bg-card), var(--bg-panel)); transition: all 0.3s;">
                            <span style="color: var(--gold); font-weight: 700; font-size: 1.1em;">⚙️ Canvas Controls & Settings</span>
                            <span id="densityToggleIcon" style="color: var(--cyan); font-size: 1.3em; transition: transform 0.3s;">▼</span>
                        </div>
                        <div id="densityControls" style="max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out;">
                    
                    <!-- Live Statistics Dashboard for Density Canvas -->
                    <div style="margin-bottom: 25px; padding: 20px; background: linear-gradient(135deg, var(--bg-panel), var(--bg-card)); border-radius: 10px; border: 2px solid var(--border);">
                        <h3 style="color: var(--gold); font-size: 1.3em; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            Live Statistics - Density Analysis
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Data Points</div>
                                <div id="liveDensityPoints" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">11</div>
                            </div>
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Current Density</div>
                                <div id="liveDensityValue" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">0.333333</div>
                            </div>
                            <div style="background: var(--bg-deep); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="color: var(--cyan); font-size: 0.85em; margin-bottom: 5px;">Basel Ratio</div>
                                <div id="liveDensityBaselRatio" style="color: var(--gold); font-size: 1.5em; font-weight: 700; font-family: 'Courier New', monospace;">0.5483</div>
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-deep); padding: 15px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 15px;">
                            <div style="color: var(--accent-purple); font-weight: 600; margin-bottom: 10px;">Basel Problem:</div>
                            <div id="liveDensityBaselInfo" style="color: var(--text-secondary); line-height: 1.8; font-size: 0.95em;">
                                • Limit: 6/π² ≈ 0.607927<br>
                                • Current: 0.333333 (54.8% of limit)<br>
                                • Status: Below average<br>
                                • ζ(2) = π²/6 connection
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-deep); padding: 15px; border-radius: 8px; border: 1px solid var(--border);">
                            <div style="color: var(--accent-green); font-weight: 600; margin-bottom: 10px;">Trend Analysis:</div>
                            <div id="liveDensityTrendInfo" style="color: var(--text-secondary); line-height: 1.8; font-size: 0.95em;">
                                • Range: n=2 to n=12<br>
                                • Average: 0.512346<br>
                                • Primes in range: 4<br>
                                • Convergence: Approaching limit
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 15px;">
                        <div style="flex: 1; min-width: 200px;">
                            <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 5px;">
                                Point Size:
                            </label>
                            <input type="range" id="pointSize" min="1" max="10" step="1" value="3" 
                                   style="width: 100%;" oninput="updateDensityVisualization(); document.getElementById('pointSizeValue').textContent = this.value + 'px'">
                            <span id="pointSizeValue" style="color: var(--gold); font-family: monospace;">3px</span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showBaselLine" checked onchange="updateDensityVisualization()">
                            <span style="color: var(--text-primary);">Show 6/π² Line</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showDensityGrid" checked onchange="updateDensityVisualization()">
                            <span style="color: var(--text-primary);">Show Grid</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showDensityLabels" checked onchange="updateDensityVisualization()">
                            <span style="color: var(--text-primary);">Show Axis Labels</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="connectPoints" checked onchange="updateDensityVisualization()">
                            <span style="color: var(--text-primary);">Connect Points</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="highlightPrimes" checked onchange="updateDensityVisualization()">
                            <span style="color: var(--text-primary);">Highlight Primes</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showTrendline" checked onchange="updateDensityVisualization()">
                            <span style="color: var(--text-primary);">Show Trendline</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="logScaleX" onchange="updateDensityVisualization()">
                            <span style="color: var(--text-primary);">Log Scale X</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                            <input type="checkbox" id="showDensityFractionLines" checked onchange="updateDensityVisualization()">
                            <span style="color: var(--text-primary);">Connect Same Densities</span>
                        </label>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Point Labeling Mode:</label>
                        <div class="radio-group" style="gap: 8px;">
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="densityLabelMode" value="none" checked onchange="updateDensityVisualization()">
                                <span>None</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="densityLabelMode" value="n" onchange="updateDensityVisualization()">
                                <span>n</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="densityLabelMode" value="density" onchange="updateDensityVisualization()">
                                <span>φ(n)/n</span>
                            </label>
                            <label class="radio-option" style="padding: 8px 12px;">
                                <input type="radio" name="densityLabelMode" value="primes" onchange="updateDensityVisualization()">
                                <span>Primes Only</span>
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: var(--bg-panel); border-radius: 8px; border: 2px solid var(--border);">
                        <label style="color: var(--cyan); font-weight: 600; display: block; margin-bottom: 8px;">Y-Axis Range:</label>
                        <div style="display: flex; gap: 15px; align-items: center;">
                            <div style="flex: 1;">
                                <label style="color: var(--text-secondary); font-size: 0.9em;">Min:</label>
                                <input type="number" id="yAxisMin" min="0" max="1" step="0.1" value="0" 
                                       style="width: 100%; padding: 8px; background: var(--bg-deep); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);"
                                       onchange="updateDensityVisualization()">
                            </div>
                            <div style="flex: 1;">
                                <label style="color: var(--text-secondary); font-size: 0.9em;">Max:</label>
                                <input type="number" id="yAxisMax" min="0" max="1" step="0.1" value="1" 
                                       style="width: 100%; padding: 8px; background: var(--bg-deep); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);"
                                       onchange="updateDensityVisualization()">
                            </div>
                            <button class="btn btn-secondary" onclick="resetDensityYAxis()" style="padding: 8px 15px;">Reset</button>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="zoomToPrimes()" style="padding: 10px 20px;">Zoom to Primes</button>
                        <button class="btn btn-secondary" onclick="fitToData()" style="padding: 10px 20px;">Fit to Data</button>
                    </div>
                            
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="controls-section">
            <div class="controls-header">Configuration & Parameters</div>

            <!-- Presets -->
            <div class="section-header">Mathematical Presets</div>
            <div class="preset-grid">
                <button class="preset-btn" onclick="applyPreset('basel')">ζ(2)=π²/6 (m=6)</button>
                <button class="preset-btn" onclick="applyPreset('totient12')">φ(12)=4</button>
                <button class="preset-btn" onclick="applyPreset('prime')">Prime Field (m=17)</button>
                <button class="preset-btn" onclick="applyPreset('highly_composite')">Highly Composite (m=60)</button>
                <button class="preset-btn" onclick="applyPreset('power_of_2')">Power of 2 (m=32)</button>
                <button class="preset-btn" onclick="applyPreset('fibonacci')">Fibonacci Prime (m=89)</button>
                <button class="preset-btn" onclick="applyPreset('mersenne')">Mersenne Prime (m=31)</button>
                <button class="preset-btn" onclick="applyPreset('perfect')">Perfect Number (m=28)</button>
                <button class="preset-btn" onclick="applyPreset('golden')">Golden Ratio (m≈161)</button>
                <button class="preset-btn" onclick="applyPreset('ramanujan')">Ramanujan τ (m=24)</button>
            </div>

            <!-- Modulus Control -->
            <div class="section-header">Modulus Parameter</div>
            <div class="control-row">
                <div class="control-item">
                    <div class="control-label">
                        <span>Modulus (m)</span>
                        <span class="control-value" id="modulusDisplay">12</span>
                    </div>
                    <input type="range" id="modulusSlider" min="1" max="200" value="12" oninput="updateModulus()">
                </div>
                <div class="control-item">
                    <label class="control-label">
                        <span>Direct Input</span>
                    </label>
                    <input type="number" id="modulusInput" min="1" max="1000" value="12" onchange="updateModulusFromInput()">
                </div>
            </div>

            <!-- Animation Controls -->
            <div class="section-header">Animation Player</div>
            <div style="background: var(--bg-panel); padding: 20px; border-radius: 10px; border: 2px solid var(--border);">
                <div class="control-row" style="margin-bottom: 15px;">
                    <div class="control-item">
                        <label class="control-label">
                            <span>Start Modulus</span>
                        </label>
                        <input type="number" id="animStartMod" min="1" max="1000" value="1" style="width: 100%;">
                    </div>
                    <div class="control-item">
                        <label class="control-label">
                            <span>End Modulus</span>
                        </label>
                        <input type="number" id="animEndMod" min="1" max="1000" value="30" style="width: 100%;">
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label class="control-label">
                        <span>Animation Speed (ms per step)</span>
                        <span class="control-value" id="animSpeedDisplay">200ms</span>
                    </label>
                    <input type="range" id="animSpeed" min="50" max="2000" step="50" value="200" 
                           style="width: 100%;" oninput="document.getElementById('animSpeedDisplay').textContent = this.value + 'ms'">
                </div>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="startAnimation()" id="playBtn">▶ Play</button>
                    <button class="btn btn-secondary" onclick="pauseAnimation()" id="pauseBtn" disabled>⏸ Pause</button>
                    <button class="btn btn-secondary" onclick="stopAnimation()" id="stopBtn" disabled>⏹ Stop</button>
                    <button class="preset-btn" onclick="setAnimRange(1, 30)" style="padding: 10px 15px;">1→30</button>
                    <button class="preset-btn" onclick="setAnimRange(1, 60)" style="padding: 10px 15px;">1→60</button>
                    <button class="preset-btn" onclick="setAnimRange(1, 100)" style="padding: 10px 15px;">1→100</button>
                    <button class="preset-btn" onclick="setAnimRange(1, 1000)" style="padding: 10px 15px;">1→1000</button>
                </div>
                <div id="animProgress" style="margin-top: 15px; text-align: center; color: var(--cyan); font-weight: 600; font-size: 1.1em;">
                    Ready to play
                </div>
            </div>



            <!-- Display Options -->
            <div class="section-header">Display Options</div>
            <div class="radio-group">
                <label class="checkbox-option">
                    <input type="checkbox" id="showLabels" checked onchange="updateVisualization()">
                    <span>Show Labels</span>
                </label>
                <label class="checkbox-option">
                    <input type="checkbox" id="showGridLines" onchange="updateVisualization()">
                    <span>Grid Lines</span>
                </label>
                <label class="checkbox-option">
                    <input type="checkbox" id="highlightUnits" onchange="updateVisualization()">
                    <span>Highlight Units</span>
                </label>
            </div>
        </div>

        <!-- Statistics Panel -->
        <div class="info-panel">
            <div class="info-title">Ring Statistics & Properties</div>
            <div class="stat-grid">
                <div class="stat-card">
                    <div class="stat-label">MODULUS</div>
                    <div class="stat-value" id="statModulus">12</div>
                    <div class="stat-details" id="statFactorization">2² × 3</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">UNITS φ(m)</div>
                    <div class="stat-value" id="statPhi">4</div>
                    <div class="stat-details" id="statUnitsList">{1,5,7,11}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ZERO DIVISORS</div>
                    <div class="stat-value" id="statZeroDivisors">7</div>
                    <div class="stat-details" id="statZDList">Non-invertible elements</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">IDEMPOTENTS</div>
                    <div class="stat-value" id="statIdempotents">4</div>
                    <div class="stat-details" id="statIdempList">{0,1,4,9}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">RING TYPE</div>
                    <div class="stat-value" id="statField">NO</div>
                    <div class="stat-details">Field Status</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">DENSITY</div>
                    <div class="stat-value" id="statDensity">0.33</div>
                    <div class="stat-details">φ(m)/m ratio</div>
                </div>
            </div>
        </div>

        <!-- Advanced Properties Panel -->
        <div class="info-panel">
            <div class="info-title">Advanced Mathematical Properties</div>
            <div class="stat-grid">
                <div class="stat-card">
                    <div class="stat-label">NILPOTENTS</div>
                    <div class="stat-value" id="statNilpotents">0</div>
                    <div class="stat-details" id="statNilpotentsList">Elements with aⁿ ≡ 0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">PRIMITIVE ROOTS</div>
                    <div class="stat-value" id="statPrimitiveRoots">—</div>
                    <div class="stat-details" id="statPrimitiveDetails">Generators of (ℤ/mℤ)×</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">QUADRATIC RESIDUES</div>
                    <div class="stat-value" id="statQuadraticRes">0</div>
                    <div class="stat-details" id="statQRList">Perfect squares mod m</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">GCD CLASSES</div>
                    <div class="stat-value" id="statGCDClasses">0</div>
                    <div class="stat-details" id="statGCDDetails">Distinct GCD values</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">EULER'S THEOREM</div>
                    <div class="stat-value" id="statEulerExp">—</div>
                    <div class="stat-details">a^φ(m) ≡ 1 (mod m)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">CARMICHAEL λ(m)</div>
                    <div class="stat-value" id="statCarmichael">—</div>
                    <div class="stat-details" id="statCarmichaelDetails">Exponent of (ℤ/mℤ)×</div>
                </div>
            </div>
        </div>

        <!-- Export Section -->
        <div class="export-section">
            <h3 style="width: 100%; color: var(--gold); text-align: center; margin-bottom: 20px;">Export Options</h3>
            
            <div style="width: 100%; margin-bottom: 25px;">
                <h4 style="color: var(--cyan); text-align: center; margin-bottom: 15px;">Export Resolution</h4>
                <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="exportResolution" value="2048" onchange="updateExportResolution()">
                        <span style="color: var(--text-primary);">2K (2048px)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="exportResolution" value="3840" checked onchange="updateExportResolution()">
                        <span style="color: var(--text-primary);">4K (3840px)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="exportResolution" value="7680" onchange="updateExportResolution()">
                        <span style="color: var(--text-primary);">8K (7680px)</span>
                    </label>
                </div>
            </div>
            
            <div style="width: 100%; display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                <button class="btn btn-primary" onclick="exportWithAnalysis()">Export All with Full Analysis Panel</button>
                <button class="btn btn-primary" onclick="exportAllCanvases()">Export All 4 Canvases (2×2 Grid)</button>
                <button class="btn btn-primary" onclick="exportData('all')">Export All Data Combined (CSV)</button>
            </div>
            </div>
        </div>

        <footer>
            <p style="font-size: 1.2em; margin-bottom: 15px;">Interactive Mathematical Visualization Tool</p>
            <p>
                Wessen Getachew | 
                <a href="https://github.com/wessengetachew" target="_blank">GitHub</a> | 
                <a href="https://twitter.com/7dview" target="_blank">@7dview</a>
            </p>
            <p style="margin-top: 15px; color: var(--text-secondary); font-size: 0.9em;">
                Exploring connections between modular arithmetic, ring theory, and geometric representations
            </p>
        </footer>
    </div>

    <script>
        // ========== CACHING SYSTEM ==========
        class ModularArithmeticCache {
            constructor() {
                this.cache = new Map();
            }
            
            getOrCompute(key, computeFn) {
                if (!this.cache.has(key)) {
                    this.cache.set(key, computeFn());
                }
                return this.cache.get(key);
            }
            
            clear() {
                this.cache.clear();
            }
            
            has(key) {
                return this.cache.has(key);
            }
            
            get(key) {
                return this.cache.get(key);
            }
            
            set(key, value) {
                this.cache.set(key, value);
            }
        }

        const globalCache = new ModularArithmeticCache();

        // ========== ELEMENT HIGHLIGHTING ==========
        let highlightedElement = null;

        // ========== TOOLTIP SYSTEM ==========
        let tooltipElement = null;
        
        function createTooltip() {
            if (!tooltipElement) {
                tooltipElement = document.createElement('div');
                tooltipElement.style.position = 'fixed';
                tooltipElement.style.background = 'linear-gradient(135deg, #1a202c, #2d3748)';
                tooltipElement.style.color = '#FFD700';
                tooltipElement.style.padding = '12px 16px';
                tooltipElement.style.borderRadius = '8px';
                tooltipElement.style.border = '2px solid #FFD700';
                tooltipElement.style.fontSize = '14px';
                tooltipElement.style.fontFamily = 'monospace';
                tooltipElement.style.pointerEvents = 'none';
                tooltipElement.style.zIndex = '10000';
                tooltipElement.style.display = 'none';
                tooltipElement.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.8)';
                tooltipElement.style.maxWidth = '400px';
                tooltipElement.style.lineHeight = '1.6';
                document.body.appendChild(tooltipElement);
            }
            return tooltipElement;
        }
        
        function showTooltip(text, x, y) {
            const tooltip = createTooltip();
            tooltip.innerHTML = text;
            tooltip.style.display = 'block';
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
        }
        
        function hideTooltip() {
            if (tooltipElement) {
                tooltipElement.style.display = 'none';
            }
        }

        // ========== URL STATE MANAGEMENT ==========
        function saveStateToURL() {
            const m = parseInt(document.getElementById('modulusInput').value);
            const tableType = document.querySelector('input[name="tableTypeCanvas1"]:checked')?.value || 'multiplication';
            const colorScheme = document.querySelector('input[name="colorSchemeCanvas1"]:checked')?.value || 'rainbow';
            const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
            const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
            const rotX = document.getElementById('rotationX')?.value || 45;
            const rotY = document.getElementById('rotationY')?.value || 45;
            
            const state = {
                m: m,
                table: tableType,
                color: colorScheme,
                pr: phaseR,
                pm: phaseM,
                rx: rotX,
                ry: rotY
            };
            
            const params = new URLSearchParams(state);
            const newURL = window.location.pathname + '?' + params.toString();
            window.history.replaceState(state, '', newURL);
        }
        
        function loadStateFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            if (params.has('m')) {
                const m = parseInt(params.get('m'));
                document.getElementById('modulusInput').value = m;
                document.getElementById('modulusSlider').value = Math.min(m, 200);
                document.getElementById('modulusDisplay').textContent = Math.min(m, 200);
            }
            
            if (params.has('table')) {
                const table = params.get('table');
                const radio = document.querySelector(`input[name="tableTypeCanvas1"][value="${table}"]`);
                if (radio) radio.checked = true;
            }
            
            if (params.has('color')) {
                const color = params.get('color');
                const radio = document.querySelector(`input[name="colorSchemeCanvas1"][value="${color}"]`);
                if (radio) radio.checked = true;
            }
            
            if (params.has('pr')) {
                document.getElementById('phaseNumerator').value = params.get('pr');
            }
            
            if (params.has('pm')) {
                document.getElementById('phaseDenominator').value = params.get('pm');
            }
            
            if (params.has('rx')) {
                document.getElementById('rotationX').value = params.get('rx');
            }
            
            if (params.has('ry')) {
                document.getElementById('rotationY').value = params.get('ry');
            }
        }

        // ========== KEYBOARD SHORTCUTS ==========
        let keyboardEnabled = true;
        
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Disable if typing in input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                if (!keyboardEnabled) return;
                
                const m = parseInt(document.getElementById('modulusInput').value);
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        if (m > 1) {
                            document.getElementById('modulusInput').value = m - 1;
                            updateModulusFromInput();
                        }
                        break;
                        
                    case 'ArrowRight':
                        e.preventDefault();
                        if (m < 1000) {
                            document.getElementById('modulusInput').value = m + 1;
                            updateModulusFromInput();
                        }
                        break;
                        
                    case 'ArrowUp':
                        e.preventDefault();
                        if (m < 991) {
                            document.getElementById('modulusInput').value = m + 10;
                            updateModulusFromInput();
                        }
                        break;
                        
                    case 'ArrowDown':
                        e.preventDefault();
                        if (m > 10) {
                            document.getElementById('modulusInput').value = m - 10;
                            updateModulusFromInput();
                        }
                        break;
                        
                    case ' ':
                        e.preventDefault();
                        if (animationInterval) {
                            pauseAnimation();
                        } else {
                            startAnimation();
                        }
                        break;
                        
                    case 'r':
                        e.preventDefault();
                        resetGCD3DView();
                        document.getElementById('phaseNumerator').value = 0;
                        document.getElementById('phaseDenominator').value = 1;
                        updateCircleVisualization();
                        showNotification('Reset', 'All views reset to defaults');
                        break;
                        
                    case 'e':
                        e.preventDefault();
                        exportAllCanvases();
                        break;
                        
                    case 'h':
                        e.preventDefault();
                        showKeyboardHelp();
                        break;
                        
                    case 'Escape':
                        e.preventDefault();
                        hideKeyboardHelp();
                        break;
                }
            });
        }
        
        function showKeyboardHelp() {
            const helpText = `
                <div style="text-align: left;">
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 12px; color: #00FFFF;">Keyboard Shortcuts</div>
                    <div style="margin-bottom: 8px;"><span style="color: #FFD700;">←/→</span> : Change modulus ±1</div>
                    <div style="margin-bottom: 8px;"><span style="color: #FFD700;">↑/↓</span> : Change modulus ±10</div>
                    <div style="margin-bottom: 8px;"><span style="color: #FFD700;">Space</span> : Play/Pause animation</div>
                    <div style="margin-bottom: 8px;"><span style="color: #FFD700;">R</span> : Reset all views</div>
                    <div style="margin-bottom: 8px;"><span style="color: #FFD700;">E</span> : Export all canvases</div>
                    <div style="margin-bottom: 8px;"><span style="color: #FFD700;">H</span> : Show this help</div>
                    <div style="margin-bottom: 8px;"><span style="color: #FFD700;">Esc</span> : Hide help</div>
                </div>
            `;
            showNotification('Keyboard Shortcuts', helpText, 0); // 0 = don't auto-hide
        }
        
        function hideKeyboardHelp() {
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();
        }

        // ========== MOUSE DRAG FOR 3D ROTATION ==========
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        function init3DMouseControls() {
            const canvas = document.getElementById('gcdCanvas');
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                const rotXSlider = document.getElementById('rotationX');
                const rotYSlider = document.getElementById('rotationY');
                
                // Update rotation based on mouse movement
                let newRotX = parseInt(rotXSlider.value) + deltaY * 0.5;
                let newRotY = parseInt(rotYSlider.value) + deltaX * 0.5;
                
                // Keep in 0-360 range
                newRotX = ((newRotX % 360) + 360) % 360;
                newRotY = ((newRotY % 360) + 360) % 360;
                
                rotXSlider.value = newRotX;
                rotYSlider.value = newRotY;
                
                updateGCDVisualization();
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.style.cursor = 'grab';
        }

        // ========== SMOOTH ANIMATION INTERPOLATION ==========
        let smoothAnimationFrame = null;
        let animationStartModulus = 1;
        let animationTargetModulus = 1;
        let animationProgress = 0;
        let animationDuration = 500; // ms per transition
        
        function smoothAnimateToModulus(targetMod) {
            const currentMod = parseInt(document.getElementById('modulusInput').value);
            animationStartModulus = currentMod;
            animationTargetModulus = targetMod;
            animationProgress = 0;
            
            const startTime = Date.now();
            
            function animateStep() {
                const elapsed = Date.now() - startTime;
                animationProgress = Math.min(elapsed / animationDuration, 1);
                
                // Ease in-out cubic
                const eased = animationProgress < 0.5
                    ? 4 * animationProgress * animationProgress * animationProgress
                    : 1 - Math.pow(-2 * animationProgress + 2, 3) / 2;
                
                const currentValue = Math.round(animationStartModulus + (animationTargetModulus - animationStartModulus) * eased);
                
                document.getElementById('modulusInput').value = currentValue;
                document.getElementById('modulusSlider').value = Math.min(currentValue, 200);
                document.getElementById('modulusDisplay').textContent = Math.min(currentValue, 200);
                updateVisualization();
                
                if (animationProgress < 1) {
                    smoothAnimationFrame = requestAnimationFrame(animateStep);
                }
            }
            
            if (smoothAnimationFrame) {
                cancelAnimationFrame(smoothAnimationFrame);
            }
            
            smoothAnimationFrame = requestAnimationFrame(animateStep);
        }

        // Toggle introduction section
        function toggleIntro() {
            const content = document.getElementById('introContent');
            const toggle = document.getElementById('introToggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }

        // Initialize intro as collapsed
        window.addEventListener('DOMContentLoaded', function() {
            const content = document.getElementById('introContent');
            const toggle = document.getElementById('introToggle');
            content.classList.add('collapsed');
            toggle.classList.add('collapsed');
            toggle.textContent = '▶';
        });

        // Mathematical utility functions
        function gcd(a, b) {
            const cacheKey = `gcd_${a}_${b}`;
            return globalCache.getOrCompute(cacheKey, () => {
                a = Math.abs(a);
                b = Math.abs(b);
                while (b !== 0) {
                    let t = b;
                    b = a % b;
                    a = t;
                }
                return a;
            });
        }

        function euler_phi(n) {
            const cacheKey = `phi_${n}`;
            return globalCache.getOrCompute(cacheKey, () => {
                if (n === 1) return 1;
                let result = n;
                let p = 2;
                let temp = n;
                while (p * p <= temp) {
                    if (temp % p === 0) {
                        while (temp % p === 0) temp /= p;
                        result -= result / p;
                    }
                    p++;
                }
                if (temp > 1) result -= result / temp;
                return Math.round(result);
            });
        }

        function isPrime(n) {
            const cacheKey = `prime_${n}`;
            return globalCache.getOrCompute(cacheKey, () => {
                if (n < 2) return false;
                if (n === 2) return true;
                if (n % 2 === 0) return false;
                for (let i = 3; i * i <= n; i += 2) {
                    if (n % i === 0) return false;
                }
                return true;
            });
        }

        function findUnits(m) {
            const cacheKey = `units_${m}`;
            return globalCache.getOrCompute(cacheKey, () => {
                if (m === 1) return [0];
                const units = [];
                for (let a = 1; a < m; a++) {
                    if (gcd(a, m) === 1) units.push(a);
                }
                return units;
            });
        }

        function findZeroDivisors(m) {
            const cacheKey = `zd_${m}`;
            return globalCache.getOrCompute(cacheKey, () => {
                const zeroDivisors = new Set();
                for (let a = 1; a < m; a++) {
                    if (gcd(a, m) > 1) {
                        zeroDivisors.add(a);
                    }
                }
                return Array.from(zeroDivisors).sort((a, b) => a - b);
            });
        }

        function findIdempotents(m) {
            const cacheKey = `idemp_${m}`;
            return globalCache.getOrCompute(cacheKey, () => {
                const idempotents = [];
                for (let a = 0; a < m; a++) {
                    if ((a * a) % m === a) idempotents.push(a);
                }
                return idempotents;
            });
        }

        function findNilpotents(m) {
            const cacheKey = `nilp_${m}`;
            return globalCache.getOrCompute(cacheKey, () => {
                const nilpotents = [];
                for (let a = 0; a < m; a++) {
                    if (a === 0) continue;
                    let temp = a;
                    for (let n = 1; n < 20; n++) {
                        temp = (temp * a) % m;
                        if (temp === 0) {
                            nilpotents.push(a);
                            break;
                        }
                    }
                }
                return nilpotents;
            });
        }

        function findQuadraticResidues(m) {
            const cacheKey = `qr_${m}`;
            return globalCache.getOrCompute(cacheKey, () => {
                const qr = new Set();
                for (let a = 0; a < m; a++) {
                    qr.add((a * a) % m);
                }
                return Array.from(qr).sort((a, b) => a - b);
            });
        }

        function findPrimitiveRoots(m) {
            const cacheKey = `primroot_${m}`;
            return globalCache.getOrCompute(cacheKey, () => {
                const units = findUnits(m);
                const phi = euler_phi(m);
                const primitiveRoots = [];
                
                for (let g of units) {
                    let isPrimitive = true;
                    const orders = new Set();
                    
                    let temp = 1;
                    for (let k = 1; k <= phi; k++) {
                        temp = (temp * g) % m;
                        orders.add(temp);
                        if (temp === 1 && k < phi) {
                            isPrimitive = false;
                            break;
                        }
                    }
                    
                    if (isPrimitive && orders.size === phi) {
                        primitiveRoots.push(g);
                    }
                }
                
                return primitiveRoots;
            });
        }

        function carmichaelLambda(n) {
            const cacheKey = `carmichael_${n}`;
            return globalCache.getOrCompute(cacheKey, () => {
                if (n === 1) return 1;
                
                const primeFactors = [];
                let temp = n;
                for (let p = 2; p <= temp; p++) {
                    let count = 0;
                    while (temp % p === 0) {
                        count++;
                        temp /= p;
                    }
                    if (count > 0) {
                        primeFactors.push({ prime: p, power: count });
                    }
                }
                
                const lambdas = [];
                for (let { prime: p, power: k } of primeFactors) {
                    if (p === 2 && k >= 3) {
                        lambdas.push(Math.pow(2, k - 2));
                    } else {
                        lambdas.push(euler_phi(Math.pow(p, k)));
                    }
                }
                
                return lambdas.reduce((a, b) => {
                    const gcdVal = gcd(a, b);
                    return (a * b) / gcdVal;
                }, 1);
            });
        }

        function countGCDClasses(m) {
            const gcdValues = new Set();
            for (let a = 0; a < m; a++) {
                gcdValues.add(gcd(a, m));
            }
            return gcdValues.size;
        }

        function getPrimeFactorization(n) {
            if (n === 1) return '1';
            if (isPrime(n)) return `${n} (prime)`;
            
            const factors = [];
            let temp = n;
            let p = 2;
            
            while (p * p <= temp) {
                let count = 0;
                while (temp % p === 0) {
                    count++;
                    temp /= p;
                }
                if (count > 0) {
                    factors.push(count === 1 ? `${p}` : `${p}^${count}`);
                }
                p++;
            }
            if (temp > 1) factors.push(`${temp}`);
            
            return factors.join(' × ');
        }

        // Color schemes
        function getRainbowColor(value, m) {
            const hue = (value / m) * 360;
            return `hsl(${hue}, 80%, 60%)`;
        }

        function getDivisibilityColor(value, m) {
            if (value === 0) return '#34495e';
            const divisors = [];
            for (let d = 2; d <= m; d++) {
                if (value % d === 0) divisors.push(d);
            }
            if (divisors.length === 0) return '#48BB78';
            const hue = 240 - (divisors.length / m) * 180;
            return `hsl(${hue}, 70%, 55%)`;
        }

        function getZeroDivisorColor(value, m, zeroDivisors) {
            if (value === 0) return '#2c3e50';
            return zeroDivisors.includes(value) ? '#e74c3c' : '#3498db';
        }

        function getIdempotentColor(value, m, idempotents) {
            if (value === 0) return '#2c3e50';
            return idempotents.includes(value) ? '#FFD700' : '#95a5a6';
        }

        // Preset configurations
        function applyPreset(presetName) {
            const presets = {
                'basel': { m: 6, table: 'multiplication', color: 'zeroDivisors', title: 'Basel Problem', msg: 'Related to ζ(2) = π²/6' },
                'totient12': { m: 12, table: 'cayley', color: 'rainbow', title: 'φ(12) = 4', msg: 'Classic totient example' },
                'prime': { m: 17, table: 'multiplication', color: 'rainbow', title: 'Prime Field', msg: 'Field structure, all non-zero elements are units' },
                'highly_composite': { m: 60, table: 'multiplication', color: 'divisibility', title: 'Highly Composite', msg: '60 = 2²×3×5 has many divisors' },
                'power_of_2': { m: 32, table: 'multiplication', color: 'idempotents', title: 'Power of 2', msg: '32 = 2⁵ with special structure' },
                'fibonacci': { m: 89, table: 'cayley', color: 'rainbow', title: 'Fibonacci Prime', msg: 'F₁₁ = 89 is prime' },
                'mersenne': { m: 31, table: 'multiplication', color: 'rainbow', title: 'Mersenne Prime', msg: '31 = 2⁵ - 1' },
                'perfect': { m: 28, table: 'multiplication', color: 'divisibility', title: 'Perfect Number', msg: '28 = 1+2+4+7+14' },
                'golden': { m: 161, table: 'multiplication', color: 'zeroDivisors', title: 'Golden Ratio', msg: '161 ≈ 100φ' },
                'ramanujan': { m: 24, table: 'multiplication', color: 'divisibility', title: 'Ramanujan', msg: 'Related to τ function' }
            };

            const preset = presets[presetName];
            if (!preset) return;

            document.getElementById('modulusInput').value = preset.m;
            document.getElementById('modulusSlider').value = Math.min(preset.m, 100);
            document.getElementById('modulusDisplay').textContent = Math.min(preset.m, 100);
            
            document.querySelector(`input[name="tableType"][value="${preset.table}"]`).checked = true;
            document.querySelector(`input[name="colorScheme"][value="${preset.color}"]`).checked = true;
            
            showNotification(preset.title, preset.msg);
            updateVisualization();
        }

        function showNotification(title, message, autoHide = 5000) {
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <h3 style="margin: 0 0 10px 0; font-size: 1.2em;">${title}</h3>
                <p style="margin: 0; line-height: 1.5;">${message}</p>
            `;
            document.body.appendChild(notification);
            
            if (autoHide > 0) {
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease-in';
                    setTimeout(() => notification.remove(), 300);
                }, autoHide);
            }
        }

        // Update functions
        function updateModulus() {
            const value = document.getElementById('modulusSlider').value;
            document.getElementById('modulusDisplay').textContent = value;
            document.getElementById('modulusInput').value = value;
            updateVisualization();
            saveStateToURL();
        }

        function updateModulusFromInput() {
            const value = parseInt(document.getElementById('modulusInput').value);
            if (value >= 1 && value <= 1000) {
                document.getElementById('modulusSlider').value = Math.min(value, 200);
                document.getElementById('modulusDisplay').textContent = Math.min(value, 200);
                updateVisualization();
                saveStateToURL();
            }
        }

        // Animation variables
        let animationInterval = null;
        let animationPaused = false;
        let currentAnimMod = 1;

        function setAnimRange(start, end) {
            document.getElementById('animStartMod').value = start;
            document.getElementById('animEndMod').value = end;
            showNotification('Animation Range Set', `Will animate from m=${start} to m=${end}`);
        }

        function startAnimation() {
            const startMod = parseInt(document.getElementById('animStartMod').value);
            const endMod = parseInt(document.getElementById('animEndMod').value);
            const speed = parseInt(document.getElementById('animSpeed').value);

            if (startMod > endMod) {
                showNotification('Invalid Range', 'Start modulus must be ≤ end modulus');
                return;
            }

            // If resuming from pause, continue from current position
            if (!animationPaused) {
                currentAnimMod = startMod;
            }
            animationPaused = false;

            // Update UI
            document.getElementById('playBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('stopBtn').disabled = false;

            // Start animation loop
            animationInterval = setInterval(() => {
                if (currentAnimMod > endMod) {
                    stopAnimation();
                    showNotification('Animation Complete', `Finished playing m=${startMod} to m=${endMod}`);
                    return;
                }

                // Update modulus
                document.getElementById('modulusInput').value = currentAnimMod;
                document.getElementById('modulusSlider').value = Math.min(currentAnimMod, 200);
                document.getElementById('modulusDisplay').textContent = Math.min(currentAnimMod, 200);
                
                // Update progress
                const progress = Math.round(((currentAnimMod - startMod) / (endMod - startMod)) * 100);
                document.getElementById('animProgress').textContent = 
                    `Playing: m = ${currentAnimMod} / ${endMod} (${progress}%)`;

                // Redraw
                updateVisualization();

                // Increment
                currentAnimMod++;
            }, speed);
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
                animationPaused = true;
                
                document.getElementById('playBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('animProgress').textContent = `Paused at m = ${currentAnimMod - 1}`;
            }
        }

        function stopAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            animationPaused = false;
            currentAnimMod = 1;
            
            document.getElementById('playBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('animProgress').textContent = 'Ready to play';
        }

        // Main visualization function
        function updateVisualization() {
            const m = parseInt(document.getElementById('modulusInput').value);
            
            // Get settings from Canvas 1 controls (preferred) or fallback to global
            let tableType, colorScheme;
            const canvas1Table = document.querySelector('input[name="tableTypeCanvas1"]:checked');
            const canvas1Color = document.querySelector('input[name="colorSchemeCanvas1"]:checked');
            
            if (canvas1Table) {
                tableType = canvas1Table.value;
                // Sync global controls
                const globalTable = document.querySelector(`input[name="tableType"][value="${tableType}"]`);
                if (globalTable) globalTable.checked = true;
            } else {
                tableType = document.querySelector('input[name="tableType"]:checked').value;
            }
            
            if (canvas1Color) {
                colorScheme = canvas1Color.value;
                // Sync global controls
                const globalColor = document.querySelector(`input[name="colorScheme"][value="${colorScheme}"]`);
                if (globalColor) globalColor.checked = true;
            } else {
                colorScheme = document.querySelector('input[name="colorScheme"]:checked').value;
            }
            
            const showLabels = document.getElementById('showLabels').checked;
            const showGridLines = document.getElementById('showGridLines') ? document.getElementById('showGridLines').checked : false;
            const highlightUnits = document.getElementById('highlightUnits') ? document.getElementById('highlightUnits').checked : false;

            // Get special elements
            const units = findUnits(m);
            const zeroDivisors = findZeroDivisors(m);
            const idempotents = findIdempotents(m);

            // Draw all canvases
            drawGridCanvas(m, tableType, colorScheme, showLabels, showGridLines, units, zeroDivisors, idempotents);
            drawCircleCanvas(m, units, highlightUnits);
            drawGCDCanvas(m);
            drawDensityCanvas(m);

            // Update statistics
            updateStatistics(m, units, zeroDivisors, idempotents);
        }

        // Canvas 1: Main Grid
        function drawGridCanvas(m, tableType, colorScheme, showLabels, showGridLines, units, zeroDivisors, idempotents) {
            const canvas = document.getElementById('gridCanvas');
            const ctx = canvas.getContext('2d');
            const size = tableType === 'cayley' ? units.length : m;
            const cellSize = Math.floor(canvas.width / size);
            
            // Get additional controls
            const showSymmetry = document.getElementById('showTableSymmetry')?.checked || false;
            const showDiagonal = document.getElementById('showDiagonal')?.checked || false;
            const alternateShading = document.getElementById('alternateShading')?.checked || false;
            const boldLabels = document.getElementById('boldLabels')?.checked || false;
            const cellOpacity = document.getElementById('cellOpacity') ? parseFloat(document.getElementById('cellOpacity').value) : 1;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const elements = tableType === 'cayley' ? units : Array.from({ length: m }, (_, i) => i);

            for (let i = 0; i < elements.length; i++) {
                for (let j = 0; j < elements.length; j++) {
                    const a = isTransposed ? elements[j] : elements[i];
                    const b = isTransposed ? elements[i] : elements[j];
                    
                    let value;
                    if (tableType === 'addition') {
                        value = (a + b) % m;
                    } else {
                        value = (a * b) % m;
                    }

                    let color;
                    switch (colorScheme) {
                        case 'rainbow':
                            color = getRainbowColor(value, m);
                            break;
                        case 'divisibility':
                            color = getDivisibilityColor(value, m);
                            break;
                        case 'zeroDivisors':
                            color = getZeroDivisorColor(value, m, zeroDivisors);
                            break;
                        case 'idempotents':
                            color = getIdempotentColor(value, m, idempotents);
                            break;
                    }

                    const x = j * cellSize;
                    const y = i * cellSize;
                    
                    // Apply alternate shading
                    let alpha = cellOpacity;
                    if (alternateShading && (i + j) % 2 === 1) {
                        alpha *= 0.7;
                    }

                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    ctx.globalAlpha = 1;
                    
                    // Highlight diagonal
                    if (showDiagonal && i === j) {
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x + 2, y + 2, cellSize - 5, cellSize - 5);
                    }
                    
                    // Highlight symmetry (if a*b = b*a)
                    if (showSymmetry && i !== j && tableType === 'multiplication') {
                        const valueReverse = (elements[j] * elements[i]) % m;
                        if (value === valueReverse) {
                            ctx.strokeStyle = '#00FFFF';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(x + 1, y + 1, cellSize - 3, cellSize - 3);
                        }
                    }

                    if (showGridLines && cellSize > 3) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);
                    }
                    
                    // Highlight if element is selected in inspector
                    if (highlightedElement !== null && (a === highlightedElement || b === highlightedElement || value === highlightedElement)) {
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x + 1, y + 1, cellSize - 3, cellSize - 3);
                        ctx.strokeStyle = '#00FFFF';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(x + 3, y + 3, cellSize - 7, cellSize - 7);
                    }

                    if (showLabels && cellSize >= 12) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `${boldLabels ? 'bold' : ''} ${Math.max(8, cellSize / 3)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.shadowBlur = 2;
                        ctx.fillText(value, x + cellSize / 2, y + cellSize / 2);
                        ctx.shadowBlur = 0;
                    }
                }
            }
            
            // Add tooltip functionality
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const col = Math.floor(mouseX / cellSize);
                const row = Math.floor(mouseY / cellSize);
                
                if (col >= 0 && col < elements.length && row >= 0 && row < elements.length) {
                    const a = elements[row];
                    const b = elements[col];
                    const op = tableType === 'addition' ? '+' : '×';
                    const result = tableType === 'addition' ? (a + b) % m : (a * b) % m;
                    
                    let tooltipText = `<strong>${a} ${op} ${b} ≡ ${result} (mod ${m})</strong>`;
                    
                    if (gcd(result, m) === 1) {
                        tooltipText += '<br><span style="color: #48BB78;">✓ Unit (invertible)</span>';
                    } else if (result !== 0) {
                        tooltipText += '<br><span style="color: #e74c3c;">Zero divisor</span>';
                    }
                    
                    if ((result * result) % m === result) {
                        tooltipText += '<br><span style="color: #FFD700;">Idempotent: ' + result + '² ≡ ' + result + '</span>';
                    }
                    
                    tooltipText += '<br><span style="color: #00FFFF; font-size: 0.9em;">Click to inspect</span>';
                    
                    showTooltip(tooltipText, e.clientX, e.clientY);
                } else {
                    hideTooltip();
                }
            };
            
            canvas.onmouseleave = () => {
                hideTooltip();
            };
            
            // Add click functionality to select element in inspector
            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const col = Math.floor(mouseX / cellSize);
                const row = Math.floor(mouseY / cellSize);
                
                if (col >= 0 && col < elements.length && row >= 0 && row < elements.length) {
                    const a = elements[row];
                    const b = elements[col];
                    const result = tableType === 'addition' ? (a + b) % m : (a * b) % m;
                    
                    // Set element in inspector
                    document.getElementById('inspectorElement').value = result;
                    updateElementInspector();
                    
                    // Scroll to inspector
                    document.getElementById('inspectorElement').scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    showNotification('Element Selected', `Inspecting element ${result}`, 2000);
                }
            };
        }

        // Canvas 2: Unit Circle with Farey Channels
        function drawCircleCanvas(m, units, highlightUnits) {
            const canvas = document.getElementById('circleCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.85;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Get phase rotation parameters
            const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
            const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
            const phaseAngle = (2 * Math.PI * phaseR) / phaseM;
            const phaseAngleDegrees = (360 * phaseR) / phaseM;
            
            // Get per-ring rotation increment
            const ringRotationIncrement = parseFloat(document.getElementById('ringRotation').value) || 0;
            const ringRotationRad = ringRotationIncrement * Math.PI / 180;
            
            // Get line thickness
            const lineThickness = document.getElementById('lineThickness') ? parseFloat(document.getElementById('lineThickness').value) : 1.5;
            
            // Update angle display with 17 decimal places
            document.getElementById('phaseAngleDisplay').textContent = 
                phaseAngleDegrees.toFixed(17) + '°';

            // Get visualization options
            const showResidueLayers = document.getElementById('showResidueLayers')?.checked !== false;
            const connectByR = document.getElementById('connectByR')?.checked || false;
            const connectToNextMod = document.getElementById('connectToNextMod')?.checked || false;
            const connectDyadicPowers = document.getElementById('connectDyadicPowers')?.checked || false;
            const highlightPrimeGCD = document.getElementById('highlightPrimeGCD')?.checked !== false;
            const showRingLabels = document.getElementById('showRingLabels')?.checked !== false;
            const showAngleMarkers = document.getElementById('showAngleMarkers')?.checked || false;
            const fadeNonCoprime = document.getElementById('fadeNonCoprime')?.checked || false;
            const pointSize = document.getElementById('circlePointSize') ? parseFloat(document.getElementById('circlePointSize').value) : 4;
            const labelMode = document.querySelector('input[name="circleLabelMode"]:checked')?.value || 'none';

            // Store all points for connections
            const pointsByModulus = new Map(); // mod -> [{r, angle, x, y, gcdVal}]
            const pointsByResidue = new Map(); // r -> [{mod, angle, x, y, gcdVal}]

            // Draw concentric rings for each modulus from 1 to m
            if (showResidueLayers) {
                for (let mod = 1; mod <= m; mod++) {
                    const ringRadius = (mod / m) * maxRadius;
                    
                    // Draw ring
                    ctx.strokeStyle = `hsla(${(mod / m) * 360}, 60%, 50%, 0.3)`;
                    ctx.lineWidth = lineThickness;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, ringRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Label modulus
                    if (showRingLabels && (mod % Math.max(1, Math.floor(m / 10)) === 0 || mod === 1 || mod === m)) {
                        ctx.fillStyle = '#718096';
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(`m=${mod}`, centerX + ringRadius + 5, centerY);
                    }
                }
            }

            // Draw all residues r/mod for each modulus (including mod=1)
            for (let mod = 1; mod <= m; mod++) {
                const ringRadius = (mod / m) * maxRadius;
                const ringIndex = mod - 1; // 0-indexed for rotation calculation
                const ringRotationOffset = ringRotationRad * ringIndex;
                
                if (!pointsByModulus.has(mod)) {
                    pointsByModulus.set(mod, []);
                }
                
                for (let r = 0; r < mod; r++) {
                    const gcdVal = gcd(r, mod);
                    
                    // Calculate angle: 2πr/mod + phase rotation + per-ring rotation offset
                    // For mod=1: angle = 0 (r=0, so 2π*0/1 = 0), at center
                    let angle = (2 * Math.PI * r) / mod + phaseAngle + ringRotationOffset;
                    // Also map -2πr/mod
                    let angleNeg = -(2 * Math.PI * r) / mod + phaseAngle + ringRotationOffset;
                    
                    // Normalize to [0, 2π)
                    angle = ((angle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                    angleNeg = ((angleNeg % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                    
                    // Position on ring
                    // For mod=1, r=0: ringRadius=maxRadius/m (very small), angle=phase
                    // This places mod=1 near center at the phase rotation angle
                    const x = centerX + ringRadius * Math.cos(angle - Math.PI / 2);
                    const y = centerY + ringRadius * Math.sin(angle - Math.PI / 2);
                    
                    const xNeg = centerX + ringRadius * Math.cos(angleNeg - Math.PI / 2);
                    const yNeg = centerY + ringRadius * Math.sin(angleNeg - Math.PI / 2);
                    
                    // Determine color based on GCD
                    let color;
                    if (gcdVal === 1 || mod === 1) {
                        color = '#FFD700'; // Gold for coprime (units) and mod=1
                    } else if (isPrime(gcdVal) && highlightPrimeGCD) {
                        color = '#00FFFF'; // Cyan for prime GCD
                    } else {
                        const hue = (gcdVal / mod) * 360;
                        color = `hsl(${hue}, 70%, 60%)`;
                    }
                    
                    // Draw point for +2πr/mod
                    ctx.fillStyle = color;
                    ctx.globalAlpha = fadeNonCoprime && gcdVal > 1 ? 0.3 : 1.0;
                    ctx.beginPath();
                    // Make mod=1 point slightly larger and more visible
                    const basePointSize = mod === 1 ? 6 : (gcdVal === 1 ? pointSize : pointSize * 0.75);
                    ctx.arc(x, y, basePointSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    
                    // Add glow for mod=1
                    if (mod === 1) {
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(x, y, basePointSize + 2, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                    
                    // Draw point for -2πr/mod (if r > 0)
                    if (r > 0) {
                        ctx.globalAlpha = fadeNonCoprime && gcdVal > 1 ? 0.15 : 0.5;
                        ctx.beginPath();
                        ctx.arc(xNeg, yNeg, basePointSize * 0.8, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                    
                    // Store point data
                    const pointData = { r, angle, x, y, gcdVal, mod };
                    pointsByModulus.get(mod).push(pointData);
                    
                    if (!pointsByResidue.has(r)) {
                        pointsByResidue.set(r, []);
                    }
                    pointsByResidue.get(r).push(pointData);
                    
                    // Label mod=1 point
                    if (mod === 1) {
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('m=1', x, y - 10);
                    }
                    
                    // Label points based on mode
                    if (labelMode !== 'none' && (mod === m || (mod > m * 0.8 && gcdVal === 1))) {
                        ctx.fillStyle = color;
                        ctx.font = 'bold 9px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        
                        let labelText = '';
                        if (labelMode === 'r') {
                            labelText = r.toString();
                        } else if (labelMode === 'fraction') {
                            labelText = `${r}/${mod}`;
                        } else if (labelMode === 'theta') {
                            const thetaVal = (2 * Math.PI * r) / mod;
                            labelText = thetaVal.toFixed(2);
                        } else if (labelMode === 'thetaNeg') {
                            const thetaVal = -(2 * Math.PI * r) / mod;
                            labelText = thetaVal.toFixed(2);
                        }
                        
                        if (labelText) {
                            ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                            ctx.shadowBlur = 3;
                            ctx.fillText(labelText, x, y + basePointSize + 3);
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                    // Label important points on outer ring
                    if (mod === m && gcdVal === 1 && r > 0 && labelMode === 'none') {
                        const labelRadius = ringRadius * 1.08;
                        const labelX = centerX + labelRadius * Math.cos(angle - Math.PI / 2);
                        const labelY = centerY + labelRadius * Math.sin(angle - Math.PI / 2);
                        
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`${r}/${mod}`, labelX, labelY);
                    }
                }
            }

            // Connect r in each modulus
            if (connectByR) {
                pointsByModulus.forEach((points, mod) => {
                    points.sort((a, b) => a.r - b.r);
                    ctx.strokeStyle = `hsla(${(mod / m) * 360}, 60%, 50%, 0.3)`;
                    ctx.lineWidth = lineThickness;
                    ctx.beginPath();
                    for (let i = 0; i < points.length; i++) {
                        const p = points[i];
                        if (i === 0) {
                            ctx.moveTo(p.x, p.y);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                    // Close the loop
                    if (points.length > 0) {
                        ctx.lineTo(points[0].x, points[0].y);
                    }
                    ctx.stroke();
                });
            }

            // Connect same residue r across different moduli
            if (connectToNextMod) {
                pointsByResidue.forEach((points, r) => {
                    if (r === 0) return; // Skip r=0
                    
                    points.sort((a, b) => a.mod - b.mod);
                    
                    const hue = (r / m) * 360;
                    ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.4)`;
                    ctx.lineWidth = lineThickness;
                    
                    ctx.beginPath();
                    for (let i = 0; i < points.length; i++) {
                        const p = points[i];
                        if (i === 0) {
                            ctx.moveTo(p.x, p.y);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                    ctx.stroke();
                });
            }

            // Connect dyadic powers r, 2r, 4r, 8r, ... (mod appropriate moduli)
            if (connectDyadicPowers) {
                for (let baseR = 1; baseR < m; baseR++) {
                    const dyadicPoints = [];
                    
                    // Find all points r×2^n for various n and moduli
                    for (let mod = 1; mod <= m; mod++) {
                        for (let n = 0; n <= 10; n++) { // Up to 2^10
                            const r = (baseR * Math.pow(2, n)) % mod;
                            
                            if (pointsByModulus.has(mod)) {
                                const points = pointsByModulus.get(mod);
                                const match = points.find(p => p.r === r);
                                if (match && gcd(r, mod) === 1) {
                                    dyadicPoints.push(match);
                                }
                            }
                        }
                    }
                    
                    // Draw connections
                    if (dyadicPoints.length > 1) {
                        const hue = (baseR / m) * 360;
                        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, 0.3)`;
                        ctx.lineWidth = 2;
                        
                        ctx.beginPath();
                        for (let i = 0; i < dyadicPoints.length - 1; i++) {
                            ctx.moveTo(dyadicPoints[i].x, dyadicPoints[i].y);
                            ctx.lineTo(dyadicPoints[i + 1].x, dyadicPoints[i + 1].y);
                        }
                        ctx.stroke();
                    }
                }
            }

            // Draw outer circle (m-ring)
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw angle markers if enabled
            if (showAngleMarkers) {
                const angles = [0, 45, 90, 135, 180, 225, 270, 315];
                angles.forEach(deg => {
                    const rad = (deg - 90) * Math.PI / 180;
                    const x1 = centerX + maxRadius * 0.95 * Math.cos(rad);
                    const y1 = centerY + maxRadius * 0.95 * Math.sin(rad);
                    const x2 = centerX + maxRadius * 1.05 * Math.cos(rad);
                    const y2 = centerY + maxRadius * 1.05 * Math.sin(rad);
                    
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    
                    const labelX = centerX + maxRadius * 1.12 * Math.cos(rad);
                    const labelY = centerY + maxRadius * 1.12 * Math.sin(rad);
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(deg + '°', labelX, labelY);
                });
            }

            // Center point
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Center label
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GCD=1', centerX, centerY - 12);
            
            // Add tooltip functionality
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find closest point
                let closestPoint = null;
                let minDist = 15; // threshold
                
                for (let mod = 1; mod <= m; mod++) {
                    const ringRadius = (mod / m) * maxRadius;
                    const ringRotationOffset = ringRotationRad * (mod - 1);
                    
                    for (let r = 0; r < mod; r++) {
                        const gcdVal = gcd(r, mod);
                        let angle = (2 * Math.PI * r) / mod + phaseAngle + ringRotationOffset;
                        angle = ((angle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                        
                        const x = centerX + ringRadius * Math.cos(angle - Math.PI / 2);
                        const y = centerY + ringRadius * Math.sin(angle - Math.PI / 2);
                        
                        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            const angleDeg = ((angle - phaseAngle - ringRotationOffset) * 180 / Math.PI) % 360;
                            closestPoint = { r, mod, gcdVal, angle: angleDeg, x, y };
                        }
                    }
                }
                
                if (closestPoint) {
                    let tooltipText = `<strong>r=${closestPoint.r}, m=${closestPoint.mod}</strong>`;
                    tooltipText += `<br>Fraction: ${closestPoint.r}/${closestPoint.mod}`;
                    tooltipText += `<br>Angle: ${closestPoint.angle.toFixed(2)}°`;
                    tooltipText += `<br>gcd(${closestPoint.r}, ${closestPoint.mod}) = ${closestPoint.gcdVal}`;
                    
                    if (closestPoint.gcdVal === 1) {
                        tooltipText += '<br><span style="color: #48BB78;">✓ Coprime (Unit)</span>';
                    } else if (isPrime(closestPoint.gcdVal)) {
                        tooltipText += '<br><span style="color: #00FFFF;">Prime GCD</span>';
                    } else {
                        tooltipText += '<br><span style="color: #718096;">Composite GCD</span>';
                    }
                    
                    showTooltip(tooltipText, e.clientX, e.clientY);
                } else {
                    hideTooltip();
                }
            };
            
            canvas.onmouseleave = () => {
                hideTooltip();
            };
        }

        // Apply k/d fraction presets
        function applyFractionPreset(k, d) {
            const rotationDegrees = (k / d) * 360;
            document.getElementById('ringRotation').value = rotationDegrees;
            document.getElementById('ringRotationValue').textContent = rotationDegrees.toFixed(1) + '°';
            
            // If "Apply to All Canvases" is checked, also update global phase
            if (document.getElementById('applyToAllCanvases').checked) {
                document.getElementById('phaseNumerator').value = k;
                document.getElementById('phaseDenominator').value = d;
            }
            
            updateCircleVisualization();
            
            showNotification(`k/d Preset Applied`, `${k}/${d} = ${rotationDegrees.toFixed(1)}° per ring${document.getElementById('applyToAllCanvases').checked ? ' (global phase updated)' : ''}`);
        }

        // Separate function to update just the circle canvas
        function updateCircleVisualization() {
            const m = parseInt(document.getElementById('modulusInput').value);
            const units = findUnits(m);
            const highlightUnits = document.getElementById('highlightUnits')?.checked || false;
            drawCircleCanvas(m, units, highlightUnits);
            updateCircleLiveStats(m);
        }
        
        // Update live statistics for Circle canvas
        function updateCircleLiveStats(m) {
            const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
            const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
            const phaseAngleDeg = (360 * phaseR) / phaseM;
            const ringRotation = parseFloat(document.getElementById('ringRotation')?.value) || 0;
            const totalResidues = (m * (m + 1)) / 2;
            
            // Count coprime and prime GCD points
            let coprimeCount = 0;
            let primeGCDCount = 0;
            for (let mod = 1; mod <= m; mod++) {
                for (let r = 0; r < mod; r++) {
                    const gcdVal = gcd(r, mod);
                    if (gcdVal === 1) coprimeCount++;
                    else if (isPrime(gcdVal)) primeGCDCount++;
                }
            }
            
            const showLayers = document.getElementById('showResidueLayers')?.checked !== false;
            const connectByR = document.getElementById('connectByR')?.checked || false;
            const connectNext = document.getElementById('connectToNextMod')?.checked || false;
            const connectDyadic = document.getElementById('connectDyadicPowers')?.checked || false;
            
            let connectionModes = [];
            if (connectByR) connectionModes.push('Connect r in m');
            if (connectNext) connectionModes.push('Radial');
            if (connectDyadic) connectionModes.push('Dyadic');
            const connectionStr = connectionModes.length > 0 ? connectionModes.join(', ') : 'None active';
            
            if (document.getElementById('liveCircleTotalResidues')) {
                document.getElementById('liveCircleTotalResidues').textContent = totalResidues;
            }
            if (document.getElementById('liveCirclePhaseAngle')) {
                document.getElementById('liveCirclePhaseAngle').textContent = phaseAngleDeg.toFixed(5) + '°';
            }
            if (document.getElementById('liveCircleRingRotation')) {
                document.getElementById('liveCircleRingRotation').textContent = ringRotation.toFixed(1) + '°';
            }
            
            if (document.getElementById('liveCircleRotationInfo')) {
                document.getElementById('liveCircleRotationInfo').innerHTML = `
                    • Phase: ${phaseR}/${phaseM} (${phaseAngleDeg.toFixed(17)}°)<br>
                    • Per-Ring: ${ringRotation.toFixed(1)}° increment<br>
                    • Layers: 1 to ${m} (${showLayers ? 'visible' : 'hidden'})<br>
                    • Connection Mode: ${connectionStr}
                `;
            }
            
            const compositeGCD = totalResidues - coprimeCount - primeGCDCount;
            if (document.getElementById('liveCircleLayerInfo')) {
                document.getElementById('liveCircleLayerInfo').innerHTML = `
                    • Coprime Points: ${coprimeCount} (gold)<br>
                    • Prime GCD Points: ${primeGCDCount} (cyan)<br>
                    • Composite GCD: ${compositeGCD}<br>
                    • Sum Formula: m(m+1)/2
                `;
            }
        }


        // Canvas 3: GCD Structure - 3D Sphere
        let autoRotateInterval = null;
        
        function drawGCDCanvas(m) {
            const canvas = document.getElementById('gcdCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Get rotation parameters
            const rotX = (document.getElementById('rotationX')?.value || 45) * Math.PI / 180;
            const rotY = (document.getElementById('rotationY')?.value || 45) * Math.PI / 180;
            const zoom = (document.getElementById('zoomLevel')?.value || 100) / 100;
            const showConnections = document.getElementById('show3DConnections')?.checked !== false;
            const showGrid = document.getElementById('showGCDSphereGrid')?.checked || false;
            const showCoprimeOnly = document.getElementById('showCoprimeOnly')?.checked || false;
            const colorByGCD = document.getElementById('colorByGCDValue')?.checked !== false;
            const showGCDLabels = document.getElementById('showGCDLabels')?.checked || false;
            const pointSizeScale = document.getElementById('gcdPointSize') ? parseFloat(document.getElementById('gcdPointSize').value) : 2;
            const gcdLabelMode = document.querySelector('input[name="gcdLabelMode"]:checked')?.value || 'none';
            
            // Update display values
            if (document.getElementById('rotXValue')) {
                document.getElementById('rotXValue').textContent = Math.round(rotX * 180 / Math.PI) + '°';
            }
            if (document.getElementById('rotYValue')) {
                document.getElementById('rotYValue').textContent = Math.round(rotY * 180 / Math.PI) + '°';
            }
            if (document.getElementById('zoomValue')) {
                document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
            }

            const baseRadius = Math.min(centerX, centerY) * 0.7 * zoom;

            // 3D rotation matrices
            function rotateX(point, angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return {
                    x: point.x,
                    y: point.y * cos - point.z * sin,
                    z: point.y * sin + point.z * cos
                };
            }

            function rotateY(point, angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return {
                    x: point.x * cos + point.z * sin,
                    y: point.y,
                    z: -point.x * sin + point.z * cos
                };
            }

            function project3D(point) {
                // Apply rotations
                let rotated = rotateY(point, rotY);
                rotated = rotateX(rotated, rotX);
                
                // Perspective projection
                const perspective = 1000;
                const scale = perspective / (perspective + rotated.z);
                
                return {
                    x: centerX + rotated.x * scale,
                    y: centerY + rotated.y * scale,
                    z: rotated.z,
                    scale: scale
                };
            }

            // Calculate positions for all elements on sphere
            const points3D = [];
            const maxGCD = Math.floor(m / 2);
            
            for (let a = 0; a < m; a++) {
                for (let b = a + 1; b < m; b++) {
                    const g = gcd(a, b);
                    if (g >= 1) {
                        // Skip if coprime-only mode is enabled and this isn't coprime
                        if (showCoprimeOnly && g > 1) continue;
                        
                        // Map to sphere using spherical coordinates
                        const theta = (2 * Math.PI * a) / m; // azimuthal
                        const phi = Math.PI * b / m; // polar
                        const r = (g / Math.max(maxGCD, 1)) * baseRadius;
                        
                        const x = r * Math.sin(phi) * Math.cos(theta);
                        const y = r * Math.sin(phi) * Math.sin(theta);
                        const z = r * Math.cos(phi);
                        
                        points3D.push({
                            a, b, g,
                            x3d: x, y3d: y, z3d: z,
                            r: r
                        });
                    }
                }
            }

            // Project all points
            points3D.forEach(p => {
                const proj = project3D({ x: p.x3d, y: p.y3d, z: p.z3d });
                p.x2d = proj.x;
                p.y2d = proj.y;
                p.depth = proj.z;
                p.scale = proj.scale;
            });

            // Sort by depth (back to front)
            points3D.sort((a, b) => a.depth - b.depth);

            // Draw sphere grid if enabled
            if (showGrid) {
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.15)';
                ctx.lineWidth = 1;
                
                // Latitude lines
                for (let lat = 0; lat <= 10; lat++) {
                    const phi = Math.PI * lat / 10;
                    ctx.beginPath();
                    for (let lon = 0; lon <= 40; lon++) {
                        const theta = 2 * Math.PI * lon / 40;
                        const x = baseRadius * Math.sin(phi) * Math.cos(theta);
                        const y = baseRadius * Math.sin(phi) * Math.sin(theta);
                        const z = baseRadius * Math.cos(phi);
                        const proj = project3D({ x, y, z });
                        if (lon === 0) {
                            ctx.moveTo(proj.x, proj.y);
                        } else {
                            ctx.lineTo(proj.x, proj.y);
                        }
                    }
                    ctx.stroke();
                }
                
                // Longitude lines
                for (let lon = 0; lon < 12; lon++) {
                    const theta = 2 * Math.PI * lon / 12;
                    ctx.beginPath();
                    for (let lat = 0; lat <= 20; lat++) {
                        const phi = Math.PI * lat / 20;
                        const x = baseRadius * Math.sin(phi) * Math.cos(theta);
                        const y = baseRadius * Math.sin(phi) * Math.sin(theta);
                        const z = baseRadius * Math.cos(phi);
                        const proj = project3D({ x, y, z });
                        if (lat === 0) {
                            ctx.moveTo(proj.x, proj.y);
                        } else {
                            ctx.lineTo(proj.x, proj.y);
                        }
                    }
                    ctx.stroke();
                }
            }

            // Draw connections if enabled
            if (showConnections) {
                points3D.forEach(p => {
                    if (p.g > 1) {
                        // Find corresponding a and b points
                        const aPoint = points3D.find(pt => pt.a === p.a && pt.b === p.a + 1);
                        const bPoint = points3D.find(pt => pt.a === p.b && pt.b === p.b + 1);
                        
                        if (aPoint) {
                            const hue = (p.g / maxGCD) * 360;
                            const alpha = 0.15 + 0.2 * (p.scale - 0.5);
                            ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${Math.max(0.1, alpha)})`;
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(p.x2d, p.y2d);
                            ctx.lineTo(aPoint.x2d, aPoint.y2d);
                            ctx.stroke();
                        }
                    }
                });
            }

            // Draw points
            points3D.forEach(p => {
                const hue = colorByGCD ? (p.g / Math.max(maxGCD, 1)) * 360 : 200;
                const brightness = 40 + 40 * p.scale;
                const alpha = 0.3 + 0.7 * p.scale;
                
                ctx.fillStyle = `hsla(${hue}, 70%, ${brightness}%, ${alpha})`;
                const size = (p.g === 1 ? 3 : 2) * p.scale * pointSizeScale;
                
                ctx.beginPath();
                ctx.arc(p.x2d, p.y2d, size, 0, 2 * Math.PI);
                ctx.fill();
                
                // Highlight coprime points
                if (p.g === 1) {
                    ctx.strokeStyle = `rgba(255, 215, 0, ${alpha * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Show labels based on mode
                if (gcdLabelMode !== 'none' && p.scale > 0.6) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 2;
                    
                    let labelText = '';
                    if (gcdLabelMode === 'pair') {
                        labelText = `(${p.a},${p.b})`;
                    } else if (gcdLabelMode === 'gcd') {
                        labelText = p.g.toString();
                    }
                    
                    if (labelText) {
                        ctx.fillText(labelText, p.x2d, p.y2d - size - 4);
                    }
                    ctx.shadowBlur = 0;
                }
                
                // Legacy GCD labels (when old checkbox is enabled)
                if (showGCDLabels && p.g > 1 && p.scale > 0.7 && gcdLabelMode === 'none') {
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.g, p.x2d, p.y2d - size - 3);
                }
            });

            // Draw axes if grid is shown
            if (showGrid) {
                const axisLength = baseRadius * 1.2;
                const axes = [
                    { dir: { x: axisLength, y: 0, z: 0 }, color: '#FF6B6B', label: 'X' },
                    { dir: { x: 0, y: axisLength, z: 0 }, color: '#4ECDC4', label: 'Y' },
                    { dir: { x: 0, y: 0, z: axisLength }, color: '#95E1D3', label: 'Z' }
                ];
                
                axes.forEach(axis => {
                    const proj = project3D(axis.dir);
                    ctx.strokeStyle = axis.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(proj.x, proj.y);
                    ctx.stroke();
                    
                    ctx.fillStyle = axis.color;
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(axis.label, proj.x, proj.y);
                });
            }

            // Center sphere outline
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseRadius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Add tooltip functionality
            canvas.onmousemove = (e) => {
                if (isDragging) return; // Don't show tooltip while dragging
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find closest point
                let closestPoint = null;
                let minDist = 20; // threshold
                
                for (let point of points3D) {
                    const dist = Math.sqrt((mouseX - point.x2d) ** 2 + (mouseY - point.y2d) ** 2);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closestPoint = point;
                    }
                }
                
                if (closestPoint) {
                    let tooltipText = `<strong>Pair (${closestPoint.a}, ${closestPoint.b})</strong>`;
                    tooltipText += `<br>gcd(${closestPoint.a}, ${closestPoint.b}) = ${closestPoint.g}`;
                    
                    if (closestPoint.g === 1) {
                        tooltipText += '<br><span style="color: #48BB78;">✓ Coprime</span>';
                    } else if (isPrime(closestPoint.g)) {
                        tooltipText += '<br><span style="color: #00FFFF;">Prime GCD</span>';
                    } else {
                        tooltipText += '<br><span style="color: #718096;">Composite GCD</span>';
                    }
                    
                    tooltipText += `<br>Depth: ${closestPoint.depth.toFixed(1)}`;
                    
                    showTooltip(tooltipText, e.clientX, e.clientY);
                } else {
                    hideTooltip();
                }
            };
            
            canvas.onmouseleave = () => {
                if (!isDragging) {
                    hideTooltip();
                }
            };
        }

        function updateGCDVisualization() {
            const m = parseInt(document.getElementById('modulusInput').value);
            drawGCDCanvas(m);
            updateGCDLiveStats(m);
        }
        
        // Update live statistics for GCD canvas
        function updateGCDLiveStats(m) {
            const rotX = document.getElementById('rotationX')?.value || 45;
            const rotY = document.getElementById('rotationY')?.value || 45;
            const zoom = document.getElementById('zoomLevel')?.value || 100;
            const autoRotate = document.getElementById('autoRotate')?.checked || false;
            
            // Count coprime pairs and total pairs
            let coprimePairs = 0;
            let totalPairs = 0;
            let maxGCD = 0;
            for (let a = 0; a < m; a++) {
                for (let b = a + 1; b < m; b++) {
                    totalPairs++;
                    const g = gcd(a, b);
                    if (g === 1) coprimePairs++;
                    if (g > maxGCD) maxGCD = g;
                }
            }
            
            const coprimePercent = totalPairs > 0 ? (coprimePairs / totalPairs * 100).toFixed(1) : 0;
            
            if (document.getElementById('liveGCDRotX')) {
                document.getElementById('liveGCDRotX').textContent = rotX + '°';
            }
            if (document.getElementById('liveGCDRotY')) {
                document.getElementById('liveGCDRotY').textContent = rotY + '°';
            }
            if (document.getElementById('liveGCDZoom')) {
                document.getElementById('liveGCDZoom').textContent = zoom + '%';
            }
            
            if (document.getElementById('liveGCDViewInfo')) {
                document.getElementById('liveGCDViewInfo').innerHTML = `
                    • Rotation: ${rotX}° × ${rotY}°<br>
                    • Perspective: ${zoom}% base<br>
                    • Auto-Rotate: ${autoRotate ? 'Active' : 'Inactive'}<br>
                    • Mouse Drag: Enabled
                `;
            }
            
            if (document.getElementById('liveGCDPairInfo')) {
                document.getElementById('liveGCDPairInfo').innerHTML = `
                    • Total Pairs: ${totalPairs}<br>
                    • Coprime Pairs: ${coprimePairs} (${coprimePercent}%)<br>
                    • Max GCD: ${maxGCD}<br>
                    • Depth Sorting: Active
                `;
            }
        }

        function resetGCD3DView() {
            document.getElementById('rotationX').value = 45;
            document.getElementById('rotationY').value = 45;
            document.getElementById('zoomLevel').value = 100;
            updateGCDVisualization();
        }

        function toggleAutoRotate() {
            const enabled = document.getElementById('autoRotate').checked;
            
            if (enabled) {
                autoRotateInterval = setInterval(() => {
                    const rotY = document.getElementById('rotationY');
                    rotY.value = (parseInt(rotY.value) + 1) % 360;
                    updateGCDVisualization();
                }, 50);
            } else {
                if (autoRotateInterval) {
                    clearInterval(autoRotateInterval);
                    autoRotateInterval = null;
                }
            }
        }

        // Canvas 4: Coprime Density
        function drawDensityCanvas(m) {
            drawDensityCanvasRange(1, m);
        }
        
        function drawDensityCanvasRange(startN, endN) {
            const canvas = document.getElementById('densityCanvas');
            const ctx = canvas.getContext('2d');

            // Get controls
            const pointSize = document.getElementById('pointSize') ? parseInt(document.getElementById('pointSize').value) : 3;
            const showBaselLine = document.getElementById('showBaselLine') ? document.getElementById('showBaselLine').checked : true;
            const showDensityGrid = document.getElementById('showDensityGrid') ? document.getElementById('showDensityGrid').checked : true;
            const showDensityLabels = document.getElementById('showDensityLabels') ? document.getElementById('showDensityLabels').checked : true;
            const connectPoints = document.getElementById('connectPoints') ? document.getElementById('connectPoints').checked : false;
            const highlightPrimes = document.getElementById('highlightPrimes') ? document.getElementById('highlightPrimes').checked : true;
            const showTrendline = document.getElementById('showTrendline') ? document.getElementById('showTrendline').checked : false;
            const logScaleX = document.getElementById('logScaleX') ? document.getElementById('logScaleX').checked : false;
            const yMin = document.getElementById('yAxisMin') ? parseFloat(document.getElementById('yAxisMin').value) : 0;
            const yMax = document.getElementById('yAxisMax') ? parseFloat(document.getElementById('yAxisMax').value) : 1;
            const showDensityFractionLines = document.getElementById('showDensityFractionLines')?.checked !== false;
            const densityLabelMode = document.querySelector('input[name="densityLabelMode"]:checked')?.value || 'none';
            
            const m = endN; // Use endN as effective m for range calculations

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Plot density for n = 1 to m (include m=1)
            const padding = 60;
            const graphWidth = canvas.width - 2 * padding;
            const graphHeight = canvas.height - 2 * padding;
            
            // Adjust y-axis range
            const yRange = yMax - yMin;

            // Draw grid if enabled
            if (showDensityGrid) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 0.5;
                for (let i = 0; i <= 10; i++) {
                    const y = padding + (i / 10) * graphHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(canvas.width - padding, y);
                    ctx.stroke();
                }
                for (let i = 0; i <= 10; i++) {
                    const x = padding + (i / 10) * graphWidth;
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, canvas.height - padding);
                    ctx.stroke();
                }
            }

            // Axes
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();

            // Connect points if enabled
            if (connectPoints) {
                ctx.beginPath();
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 1;
                let firstPoint = true;
                for (let n = 1; n <= m; n++) {
                    const phi = euler_phi(n);
                    const density = phi / n;
                    const x = padding + ((n - 1) / (m - 1)) * graphWidth;
                    const y = canvas.height - padding - density * graphHeight;
                    if (firstPoint) {
                        ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }

            // Plot points (start from startN to endN)
            const densityData = [];
            const densityGroups = new Map(); // Group by density value
            
            const rangeSize = endN - startN + 1;
            
            for (let n = startN; n <= endN; n++) {
                const phi = euler_phi(n);
                const density = phi / n;
                const xPos = logScaleX ? (Math.log(n) - Math.log(startN)) / (Math.log(endN) - Math.log(startN)) : (n - startN) / Math.max(1, rangeSize - 1);
                const x = padding + xPos * graphWidth;
                const y = canvas.height - padding - ((density - yMin) / yRange) * graphHeight;

                densityData.push({ n, density, x, y, isPrime: isPrime(n) });
                
                // Group points by density for connecting same densities
                const densityKey = density.toFixed(6);
                if (!densityGroups.has(densityKey)) {
                    densityGroups.set(densityKey, []);
                }
                densityGroups.get(densityKey).push({ n, x, y, density });

                const isCurrentM = n === endN;
                const isFirst = n === startN;
                
                ctx.fillStyle = isCurrentM ? '#FFD700' : (isFirst ? '#00FF00' : (highlightPrimes && isPrime(n) ? '#FF6B9D' : '#00FFFF'));
                ctx.beginPath();
                ctx.arc(x, y, isCurrentM ? pointSize * 2 : (isFirst ? pointSize * 1.5 : pointSize), 0, 2 * Math.PI);
                ctx.fill();
                
                // Label points based on mode (only if range is reasonable)
                if (densityLabelMode !== 'none' && rangeSize <= 200) {
                    let shouldLabel = false;
                    if (densityLabelMode === 'n') {
                        shouldLabel = true;
                    } else if (densityLabelMode === 'density') {
                        shouldLabel = true;
                    } else if (densityLabelMode === 'primes') {
                        shouldLabel = isPrime(n);
                    }
                    
                    if (shouldLabel) {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 9px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.shadowBlur = 2;
                        
                        let labelText = '';
                        if (densityLabelMode === 'n' || densityLabelMode === 'primes') {
                            labelText = n.toString();
                        } else if (densityLabelMode === 'density') {
                            labelText = density.toFixed(3);
                        }
                        
                        ctx.fillText(labelText, x, y - pointSize - 3);
                        ctx.shadowBlur = 0;
                    }
                }
            }
            
            // Draw lines connecting same densities
            if (showDensityFractionLines) {
                const drawnFractions = new Set();
                densityGroups.forEach((points, densityKey) => {
                    if (points.length >= 2) {
                        // Sort points by x position
                        points.sort((a, b) => a.n - b.n);
                        
                        // Find the reduced fraction for this density
                        const density = points[0].density;
                        let bestNum = 1, bestDen = 1, minError = 1;
                        
                        // Try common denominators up to 20
                        for (let d = 1; d <= 20; d++) {
                            const num = Math.round(density * d);
                            const actualDensity = num / d;
                            const error = Math.abs(actualDensity - density);
                            if (error < minError) {
                                minError = error;
                                bestNum = num;
                                bestDen = d;
                            }
                        }
                        
                        // Simplify fraction
                        const g = gcd(bestNum, bestDen);
                        bestNum /= g;
                        bestDen /= g;
                        
                        const fractionKey = `${bestNum}/${bestDen}`;
                        
                        // Only draw if this fraction hasn't been drawn and error is small
                        if (minError < 0.001 && !drawnFractions.has(fractionKey)) {
                            drawnFractions.add(fractionKey);
                            
                            // Draw dashed line
                            ctx.strokeStyle = `hsla(${(bestNum / bestDen) * 360}, 70%, 60%, 0.4)`;
                            ctx.lineWidth = 1.5;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            for (let i = 0; i < points.length; i++) {
                                if (i === 0) {
                                    ctx.moveTo(points[i].x, points[i].y);
                                } else {
                                    ctx.lineTo(points[i].x, points[i].y);
                                }
                            }
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                            // Label the fraction on y-axis
                            const yPos = points[0].y;
                            if (yPos >= padding && yPos <= canvas.height - padding) {
                                ctx.fillStyle = `hsl(${(bestNum / bestDen) * 360}, 70%, 60%)`;
                                ctx.font = 'bold 11px Arial';
                                ctx.textAlign = 'right';
                                ctx.fillText(fractionKey, padding - 8, yPos + 4);
                            }
                        }
                    }
                });
            }
            
            // Draw trendline if enabled
            if (showTrendline && densityData.length > 2) {
                // Simple linear regression
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                densityData.forEach(d => {
                    const xNorm = d.n / m;
                    sumX += xNorm;
                    sumY += d.density;
                    sumXY += xNorm * d.density;
                    sumX2 += xNorm * xNorm;
                });
                const n = densityData.length;
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                ctx.strokeStyle = '#9F7AEA';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const x1 = padding;
                const y1 = canvas.height - padding - ((intercept - yMin) / yRange) * graphHeight;
                const x2 = canvas.width - padding;
                const y2 = canvas.height - padding - ((slope + intercept - yMin) / yRange) * graphHeight;
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Reference line for 6/π²
            if (showBaselLine) {
                const sixOverPiSquared = 6 / (Math.PI * Math.PI);
                if (sixOverPiSquared >= yMin && sixOverPiSquared <= yMax) {
                    const refY = canvas.height - padding - ((sixOverPiSquared - yMin) / yRange) * graphHeight;
                    ctx.strokeStyle = '#9F7AEA';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.moveTo(padding, refY);
                    ctx.lineTo(canvas.width - padding, refY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    if (showDensityLabels) {
                        ctx.fillStyle = '#9F7AEA';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'right';
                        ctx.fillText('6/π² ≈ 0.608', canvas.width - padding - 10, refY - 10);
                    }
                }
            }

            // Labels
            if (showDensityLabels) {
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                
                // Only show axis labels if fraction lines are not enabled
                // This prevents overlap with fraction labels on y-axis
                if (!showDensityFractionLines) {
                    ctx.fillText('φ(n)/n', padding / 2, canvas.height / 2);
                }
                ctx.fillText(`n (${startN} to ${endN})`, canvas.width / 2, canvas.height - padding / 2);
            }
            
            // Add tooltip functionality
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find closest point
                let closestPoint = null;
                let minDist = 15; // threshold
                
                for (let n = 1; n <= m; n++) {
                    const phi = euler_phi(n);
                    const density = phi / n;
                    const x = padding + ((n - 1) / Math.max(1, m - 1)) * graphWidth;
                    const y = canvas.height - padding - density * graphHeight;
                    
                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closestPoint = { n, phi, density };
                    }
                }
                
                if (closestPoint) {
                    const baselRatio = closestPoint.density / (6 / (Math.PI * Math.PI));
                    
                    let tooltipText = `<strong>n = ${closestPoint.n}</strong>`;
                    tooltipText += `<br>φ(${closestPoint.n}) = ${closestPoint.phi}`;
                    tooltipText += `<br>Density: ${closestPoint.density.toFixed(6)}`;
                    tooltipText += `<br>vs Basel: ${baselRatio.toFixed(4)}×`;
                    
                    if (isPrime(closestPoint.n)) {
                        tooltipText += '<br><span style="color: #48BB78;">✓ Prime</span>';
                    } else {
                        tooltipText += `<br>${getPrimeFactorization(closestPoint.n)}`;
                    }
                    
                    showTooltip(tooltipText, e.clientX, e.clientY);
                } else {
                    hideTooltip();
                }
            };
            
            canvas.onmouseleave = () => {
                hideTooltip();
            };
        }

        function updateDensityVisualization() {
            const m = parseInt(document.getElementById('modulusInput').value);
            drawDensityCanvas(m);
            updateDensityLiveStats(m);
        }
        
        // Update live statistics for Density canvas
        function updateDensityLiveStats(m) {
            const units = findUnits(m);
            const currentDensity = units.length / m;
            const baselLimit = 6 / (Math.PI * Math.PI);
            const baselRatio = currentDensity / baselLimit;
            
            const dataPoints = m - 1; // from 2 to m
            
            // Calculate average density and count primes
            let sumDensity = 0;
            let primeCount = 0;
            for (let n = 2; n <= m; n++) {
                const phi = euler_phi(n);
                sumDensity += phi / n;
                if (isPrime(n)) primeCount++;
            }
            const avgDensity = dataPoints > 0 ? sumDensity / dataPoints : 0;
            
            const status = currentDensity >= baselLimit ? 'Above average' : 'Below average';
            
            if (document.getElementById('liveDensityPoints')) {
                document.getElementById('liveDensityPoints').textContent = dataPoints;
            }
            if (document.getElementById('liveDensityValue')) {
                document.getElementById('liveDensityValue').textContent = currentDensity.toFixed(6);
            }
            if (document.getElementById('liveDensityBaselRatio')) {
                document.getElementById('liveDensityBaselRatio').textContent = baselRatio.toFixed(4);
            }
            
            if (document.getElementById('liveDensityBaselInfo')) {
                document.getElementById('liveDensityBaselInfo').innerHTML = `
                    • Limit: 6/π² ≈ ${baselLimit.toFixed(6)}<br>
                    • Current: ${currentDensity.toFixed(6)} (${(baselRatio * 100).toFixed(1)}% of limit)<br>
                    • Status: ${status}<br>
                    • ζ(2) = π²/6 connection
                `;
            }
            
            if (document.getElementById('liveDensityTrendInfo')) {
                document.getElementById('liveDensityTrendInfo').innerHTML = `
                    • Range: n=2 to n=${m}<br>
                    • Average: ${avgDensity.toFixed(6)}<br>
                    • Primes in range: ${primeCount}<br>
                    • Convergence: ${avgDensity > 0.5 ? 'Approaching limit' : 'Early range'}
                `;
            }
        }

        // Get selected export resolution
        function getExportResolution() {
            const selected = document.querySelector('input[name="exportResolution"]:checked');
            return selected ? parseInt(selected.value) : 3840;
        }

        function updateExportResolution() {
            const resolution = getExportResolution();
            const resText = resolution === 2048 ? '2K' : resolution === 3840 ? '4K' : '8K';
            showNotification('Export Resolution Updated', `All exports will now be ${resText} (${resolution}px)`);
        }

        // Update statistics
        function updateStatistics(m, units, zeroDivisors, idempotents) {
            // Basic Ring Statistics (top panel)
            document.getElementById('statModulus').textContent = m;
            document.getElementById('statFactorization').textContent = getPrimeFactorization(m);
            
            document.getElementById('statPhi').textContent = units.length;
            const unitsDisplay = units.length <= 20 ? `{${units.join(',')}}` : `{${units.slice(0, 20).join(',')}, ...}`;
            document.getElementById('statUnitsList').textContent = unitsDisplay;
            
            document.getElementById('statZeroDivisors').textContent = zeroDivisors.length;
            const zdDisplay = zeroDivisors.length <= 20 ? `{${zeroDivisors.join(',')}}` : `{${zeroDivisors.slice(0, 20).join(',')}, ...}`;
            document.getElementById('statZDList').textContent = zdDisplay;
            
            document.getElementById('statIdempotents').textContent = idempotents.length;
            const idDisplay = idempotents.length <= 20 ? `{${idempotents.join(',')}}` : `{${idempotents.slice(0, 20).join(',')}, ...}`;
            document.getElementById('statIdempList').textContent = idDisplay;
            
            document.getElementById('statField').textContent = isPrime(m) ? 'YES' : 'NO';
            document.getElementById('statDensity').textContent = (units.length / m).toFixed(3);

            // Advanced Properties (bottom panel)
            const nilpotents = findNilpotents(m);
            document.getElementById('statNilpotents').textContent = nilpotents.length;
            const nilpDisplay = nilpotents.length > 0 && nilpotents.length <= 15 ? 
                `{${nilpotents.join(',')}}` : 
                nilpotents.length > 0 ? `{${nilpotents.slice(0, 10).join(',')}, ...}` : 'None';
            document.getElementById('statNilpotentsList').textContent = nilpDisplay;

            // Primitive roots (only for certain m)
            const primitiveRoots = findPrimitiveRoots(m);
            if (primitiveRoots.length > 0) {
                document.getElementById('statPrimitiveRoots').textContent = primitiveRoots.length;
                const prDisplay = primitiveRoots.length <= 10 ? `{${primitiveRoots.join(',')}}` : `${primitiveRoots.length} roots exist`;
                document.getElementById('statPrimitiveDetails').textContent = prDisplay;
            } else {
                document.getElementById('statPrimitiveRoots').textContent = '0';
                document.getElementById('statPrimitiveDetails').textContent = 'No primitive roots';
            }

            // Quadratic residues
            const qr = findQuadraticResidues(m);
            document.getElementById('statQuadraticRes').textContent = qr.length;
            const qrDisplay = qr.length <= 15 ? `{${qr.join(',')}}` : `{${qr.slice(0, 12).join(',')}, ...}`;
            document.getElementById('statQRList').textContent = qrDisplay;

            // GCD classes
            const gcdClasses = countGCDClasses(m);
            document.getElementById('statGCDClasses').textContent = gcdClasses;
            const divisors = [];
            for (let d = 1; d <= m; d++) {
                if (m % d === 0) divisors.push(d);
            }
            document.getElementById('statGCDDetails').textContent = `Divisors: {${divisors.join(',')}}`;

            // Euler's theorem exponent
            const phi = euler_phi(m);
            document.getElementById('statEulerExp').textContent = `φ(${m}) = ${phi}`;

            // Carmichael lambda
            const lambda = carmichaelLambda(m);
            document.getElementById('statCarmichael').textContent = lambda;
            document.getElementById('statCarmichaelDetails').textContent = 
                lambda === phi ? 'λ(m) = φ(m)' : `λ(m) < φ(m)`;
            
            // Update Live Statistics Dashboard
            updateLiveStatistics(m, units, zeroDivisors, idempotents, primitiveRoots);
            
            // Update live stats for all canvases
            updateCircleLiveStats(m);
            updateGCDLiveStats(m);
            updateDensityLiveStats(m);
            
            // Update Element Inspector (if element is set)
            updateElementInspector();
        }
        
        // Live Statistics Dashboard Update
        function updateLiveStatistics(m, units, zeroDivisors, idempotents, primitiveRoots) {
            // Update main stats
            document.getElementById('liveStatModulus').textContent = m;
            document.getElementById('liveStatPhi').textContent = units.length;
            document.getElementById('liveStatDensity').textContent = (units.length / m).toFixed(6);
            
            // Update properties
            const unitsDisplay = units.length <= 8 ? `{${units.join(', ')}}` : `{${units.slice(0, 8).join(', ')}, ...}`;
            const idempDisplay = idempotents.length <= 6 ? `{${idempotents.join(', ')}}` : `{${idempotents.slice(0, 6).join(', ')}, ...}`;
            
            const primeTest = isPrime(m) ? `<span style="color: var(--accent-green);">✓ Prime</span>` : `Composite (${getPrimeFactorization(m)})`;
            
            document.getElementById('liveStatProperties').innerHTML = `
                • <strong style="color: var(--text-primary);">Units:</strong> ${unitsDisplay}<br>
                • <strong style="color: var(--text-primary);">Zero Divisors:</strong> ${zeroDivisors.length} elements<br>
                • <strong style="color: var(--text-primary);">Idempotents:</strong> ${idempDisplay}<br>
                • <strong style="color: var(--text-primary);">Prime Test:</strong> ${primeTest}
            `;
            
            // Find previous and next prime
            let prevPrime = m - 1;
            while (prevPrime > 1 && !isPrime(prevPrime)) prevPrime--;
            
            let nextPrime = m + 1;
            while (nextPrime < m + 100 && !isPrime(nextPrime)) nextPrime++;
            
            const lambda = carmichaelLambda(m);
            
            document.getElementById('liveStatRelated').innerHTML = `
                • <strong style="color: var(--text-primary);">Previous Prime:</strong> <span style="color: var(--gold);">${prevPrime}</span> | 
                  <strong style="color: var(--text-primary);">Next Prime:</strong> <span style="color: var(--gold);">${nextPrime}</span><br>
                • <strong style="color: var(--text-primary);">Carmichael λ(${m}):</strong> <span style="color: var(--cyan);">${lambda}</span><br>
                • <strong style="color: var(--text-primary);">Group Order:</strong> <span style="color: var(--accent-purple);">${units.length}</span>
            `;
        }
        
        // Element Inspector Functions
        function updateElementInspector() {
            const m = parseInt(document.getElementById('modulusInput').value);
            let element = parseInt(document.getElementById('inspectorElement').value);
            
            // Clamp element to valid range
            if (element < 0) element = 0;
            if (element >= m) element = m - 1;
            document.getElementById('inspectorElement').value = element;
            
            // Update display
            document.getElementById('inspectorElementTitle').textContent = element;
            document.getElementById('inspectorModulus').textContent = m;
            
            // Calculate properties
            const gcdVal = gcd(element, m);
            const isUnit = gcdVal === 1;
            
            // Calculate order
            let order = 0;
            if (isUnit) {
                let temp = 1;
                for (let k = 1; k <= m; k++) {
                    temp = (temp * element) % m;
                    if (temp === 1) {
                        order = k;
                        break;
                    }
                }
            }
            
            // Calculate inverse
            let inverse = null;
            if (isUnit) {
                for (let i = 1; i < m; i++) {
                    if ((element * i) % m === 1) {
                        inverse = i;
                        break;
                    }
                }
            }
            
            // Calculate powers
            let powers = [];
            let temp = element;
            for (let k = 1; k <= Math.min(order || 10, 10); k++) {
                powers.push(`${element}<sup>${k}</sup>=${temp}`);
                temp = (temp * element) % m;
            }
            
            // Generate subgroup
            let subgroup = new Set();
            if (isUnit && order > 0) {
                temp = 1;
                for (let k = 0; k < order; k++) {
                    subgroup.add(temp);
                    temp = (temp * element) % m;
                }
            }
            const subgroupDisplay = subgroup.size > 0 ? `{${Array.from(subgroup).sort((a,b) => a-b).join(', ')}}` : 'N/A';
            
            // Check if idempotent
            const isIdempotent = (element * element) % m === element;
            
            // Check if nilpotent
            let isNilpotent = false;
            temp = element;
            for (let k = 1; k < 20; k++) {
                temp = (temp * element) % m;
                if (temp === 0) {
                    isNilpotent = true;
                    break;
                }
            }
            
            // Build display
            let html = '';
            
            if (isUnit) {
                html += `• <strong style="color: var(--text-primary);">Order:</strong> <span style="color: var(--cyan);">${order}</span> (${element}<sup>${order}</sup> ≡ 1)<br>`;
                html += `• <strong style="color: var(--text-primary);">Unit:</strong> <span style="color: var(--accent-green);">✓ Yes</span> (gcd(${element},${m})=1)<br>`;
                html += `• <strong style="color: var(--text-primary);">Inverse:</strong> <span style="color: var(--gold);">${element}⁻¹ ≡ ${inverse}</span><br>`;
                html += `• <strong style="color: var(--text-primary);">Powers:</strong> ${powers.join(', ')}<br>`;
                html += `• <strong style="color: var(--text-primary);">Generates:</strong> ${subgroupDisplay}`;
            } else {
                html += `• <strong style="color: var(--text-primary);">Order:</strong> <span style="color: var(--text-secondary);">N/A (not a unit)</span><br>`;
                html += `• <strong style="color: var(--text-primary);">Unit:</strong> <span style="color: #e74c3c;">✗ No</span> (gcd(${element},${m})=${gcdVal})<br>`;
                html += `• <strong style="color: var(--text-primary);">Zero Divisor:</strong> <span style="color: #e74c3c;">✓ Yes</span><br>`;
                
                if (isIdempotent) {
                    html += `• <strong style="color: var(--text-primary);">Idempotent:</strong> <span style="color: var(--gold);">✓ Yes</span> (${element}² ≡ ${element})<br>`;
                }
                
                if (isNilpotent) {
                    html += `• <strong style="color: var(--text-primary);">Nilpotent:</strong> <span style="color: var(--accent-purple);">✓ Yes</span> (${element}<sup>n</sup> ≡ 0 for some n)`;
                }
            }
            
            document.getElementById('inspectorDetails').innerHTML = html;
        }
        
        // Highlight element in multiplication table
        function highlightElementInTable() {
            const element = parseInt(document.getElementById('inspectorElement').value);
            highlightedElement = element;
            updateVisualization();
            showNotification('Highlighted', `Element ${element} highlighted in multiplication table`);
        }
        
        function showSubgroupGenerated() {
            const m = parseInt(document.getElementById('modulusInput').value);
            const element = parseInt(document.getElementById('inspectorElement').value);
            const gcdVal = gcd(element, m);
            
            if (gcdVal !== 1) {
                showNotification('Not a Unit', `Element ${element} is not a unit (gcd=${gcdVal}), cannot generate subgroup`);
                return;
            }
            
            // Generate subgroup
            const subgroup = new Set();
            let temp = 1;
            do {
                subgroup.add(temp);
                temp = (temp * element) % m;
            } while (temp !== 1);
            
            const subgroupArray = Array.from(subgroup).sort((a,b) => a-b);
            
            showNotification('Subgroup Generated', `⟨${element}⟩ = {${subgroupArray.join(', ')}}<br>Order: ${subgroupArray.length}`, 8000);
        }

        // Export functions with titles and descriptions
        function exportCanvas(canvasId) {
            let m = parseInt(document.getElementById('modulusInput').value);
            let rangeInfo = '';
            
            // Check if canvas is in independent mode
            if (canvasId === 'density' && canvasIndependentStates.density.active) {
                const start = canvasIndependentStates.density.start;
                const end = canvasIndependentStates.density.end;
                m = end;
                rangeInfo = ` [Range: ${start}-${end}]`;
            } else if (canvasIndependentStates[canvasId]?.active) {
                m = canvasIndependentStates[canvasId].modulus;
                rangeInfo = ' [Independent Mode]';
            }
            
            // Get current Canvas 1 settings
            const tableTypeElem = document.querySelector('input[name="tableTypeCanvas1"]:checked') || 
                                 document.querySelector('input[name="tableType"]:checked');
            const colorSchemeElem = document.querySelector('input[name="colorSchemeCanvas1"]:checked') || 
                                   document.querySelector('input[name="colorScheme"]:checked');
            
            const tableType = tableTypeElem.value;
            const colorScheme = colorSchemeElem.value;
            const units = findUnits(m);
            const zeroDivisors = findZeroDivisors(m);
            const idempotents = findIdempotents(m);
            
            // Get phase rotation for circle canvas
            const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
            const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
            const phaseAngleDeg = (360 * phaseR) / phaseM;
            
            // Count total residues in all layers
            const totalResidues = (m * (m + 1)) / 2;
            
            // Count coprime pairs for GCD
            let coprimePairs = 0;
            for (let a = 0; a < m; a++) {
                for (let b = a + 1; b < m; b++) {
                    if (gcd(a, b) === 1) coprimePairs++;
                }
            }
            
            const canvasMap = {
                'grid': { 
                    id: 'gridCanvas', 
                    title: '⊗ Multiplication Table',
                    subtitle: `ℤ/${m}ℤ (m=${m}) · ${tableType} · ${colorScheme} · φ(${m})=${units.length} units · ${zeroDivisors.length} zero divisors`
                },
                'circle': { 
                    id: 'circleCanvas', 
                    title: '○ Unit Circle - Farey Channels',
                    subtitle: `m=${m} · Layers 1→${m} (${totalResidues} residues) · Phase ${phaseR}/${phaseM} = ${phaseAngleDeg.toFixed(3)}° · φ(${m})=${units.length}`
                },
                'gcd': { 
                    id: 'gcdCanvas', 
                    title: '⊚ GCD Structure - 3D Sphere',
                    subtitle: `m=${m} · 3D Spherical View · ${coprimePairs} coprime pairs · φ(${m})=${units.length} · Density ${(units.length/m).toFixed(4)}`
                },
                'density': { 
                    id: 'densityCanvas', 
                    title: '◬ Coprime Density Analysis',
                    subtitle: `m=${m} · φ(m)/m = ${(units.length/m).toFixed(6)} · Basel limit 6/π² ≈ 0.6079 · ${m} data points`
                }
            };
            
            const info = canvasMap[canvasId];
            const canvas = document.getElementById(info.id);
            
            // Create export canvas with title and description
            const exportCanvas = document.createElement('canvas');
            const margin = 200;
            exportCanvas.width = 3840;
            exportCanvas.height = 3840 + margin;
            const ctx = exportCanvas.getContext('2d', { alpha: false });
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Draw title
            ctx.fillStyle = '#1a202c';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(info.title, exportCanvas.width / 2, 80);
            
            // Draw subtitle (with metrics)
            ctx.font = '38px Arial';
            ctx.fillStyle = '#4a5568';
            
            // Split long subtitle into multiple lines if needed
            const maxWidth = exportCanvas.width - 200;
            const words = info.subtitle.split(' · ');
            let lines = [];
            let currentLine = words[0];
            
            for (let i = 1; i < words.length; i++) {
                const testLine = currentLine + ' · ' + words[i];
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && i > 0) {
                    lines.push(currentLine);
                    currentLine = words[i];
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine);
            
            let subtitleY = 130;
            for (let line of lines) {
                ctx.fillText(line, exportCanvas.width / 2, subtitleY);
                subtitleY += 45;
            }
            
            // Draw canvas
            ctx.save();
            ctx.translate(0, margin);
            const sourceCanvas = document.getElementById(info.id);
            ctx.scale(3840 / sourceCanvas.width, 3840 / sourceCanvas.height);
            ctx.drawImage(sourceCanvas, 0, 0);
            ctx.restore();
            
            // ========== ADD LEGEND PANEL TO RIGHT SIDE ==========
            const legendWidth = 700;
            const legendX = 3840 + 50;
            const legendY = margin + 50;
            const legendHeight = 3840 - 100;
            
            // Expand canvas width to include legend
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = 3840 + legendWidth + 100;
            finalCanvas.height = 3840 + margin;
            const finalCtx = finalCanvas.getContext('2d', { alpha: false });
            
            // Copy everything we've drawn so far
            finalCtx.fillStyle = '#ffffff';
            finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
            finalCtx.drawImage(exportCanvas, 0, 0);
            
            // Now draw legend on final canvas
            finalCtx.fillStyle = '#f7fafc';
            finalCtx.fillRect(legendX - 20, legendY - 20, legendWidth + 40, legendHeight + 40);
            finalCtx.strokeStyle = '#cbd5e0';
            finalCtx.lineWidth = 4;
            finalCtx.strokeRect(legendX - 20, legendY - 20, legendWidth + 40, legendHeight + 40);
            
            finalCtx.fillStyle = '#2d3748';
            finalCtx.font = 'bold 56px Arial';
            finalCtx.textAlign = 'left';
            finalCtx.fillText('Legend', legendX, legendY + 50);
            
            let yPos = legendY + 120;
            const lineHeight = 46;
            const sectionGap = 60;
            const smallFont = '34px Arial';
            const mediumFont = '38px Arial';
            
            // Modulus info
            finalCtx.font = 'bold 46px Arial';
            finalCtx.fillStyle = '#667eea';
            finalCtx.fillText('Modulus', legendX, yPos);
            yPos += lineHeight + 8;
            
            finalCtx.font = mediumFont;
            finalCtx.fillStyle = '#2d3748';
            finalCtx.fillText(`m = ${m}`, legendX, yPos);
            yPos += lineHeight;
            
            finalCtx.font = smallFont;
            finalCtx.fillStyle = '#4a5568';
            finalCtx.fillText(`${getPrimeFactorization(m)}`, legendX + 15, yPos);
            yPos += lineHeight;
            
            if (isPrime(m)) {
                finalCtx.fillStyle = '#48BB78';
                finalCtx.fillText(`✓ Prime (Field)`, legendX + 15, yPos);
            } else {
                finalCtx.fillStyle = '#718096';
                finalCtx.fillText(`Composite`, legendX + 15, yPos);
            }
            yPos += sectionGap;
            
            // Units
            finalCtx.font = 'bold 46px Arial';
            finalCtx.fillStyle = '#667eea';
            finalCtx.fillText('Units (ℤ/mℤ)×', legendX, yPos);
            yPos += lineHeight + 8;
            
            finalCtx.font = mediumFont;
            finalCtx.fillStyle = '#2d3748';
            finalCtx.fillText(`φ(${m}) = ${units.length}`, legendX, yPos);
            yPos += lineHeight;
            
            finalCtx.font = smallFont;
            finalCtx.fillStyle = '#4a5568';
            const density = units.length / m;
            finalCtx.fillText(`Density: ${density.toFixed(6)}`, legendX + 15, yPos);
            yPos += lineHeight;
            
            const baselLimit = 6 / (Math.PI * Math.PI);
            finalCtx.fillText(`Basel: ${baselLimit.toFixed(6)}`, legendX + 15, yPos);
            yPos += lineHeight;
            
            if (units.length <= 18) {
                const unitStr = `{${units.join(',')}}`;
                const maxLen = 35;
                finalCtx.fillText(unitStr.length > maxLen ? unitStr.substring(0, maxLen) + '..}' : unitStr, legendX + 15, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap;
            
            // Ring Statistics Section
            finalCtx.font = 'bold 46px Arial';
            finalCtx.fillStyle = '#667eea';
            finalCtx.fillText('Ring Statistics', legendX, yPos);
            yPos += lineHeight + 8;
            
            finalCtx.font = mediumFont;
            finalCtx.fillStyle = '#2d3748';
            finalCtx.fillText(`Zero Divisors: ${zeroDivisors.length}`, legendX, yPos);
            yPos += lineHeight;
            
            finalCtx.fillText(`Idempotents: ${idempotents.length}`, legendX, yPos);
            yPos += lineHeight;
            
            finalCtx.font = smallFont;
            finalCtx.fillStyle = '#4a5568';
            if (idempotents.length <= 12) {
                finalCtx.fillText(`{${idempotents.join(',')}}`, legendX + 15, yPos);
                yPos += lineHeight;
            }
            
            finalCtx.fillText(`Field: ${isPrime(m) ? 'YES' : 'NO'}`, legendX + 15, yPos);
            yPos += lineHeight + sectionGap;
            
            // Canvas-specific metrics
            if (canvasId === 'grid') {
                // Table info
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Canvas Settings', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`Type: ${tableType}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                finalCtx.fillText(`Colors: ${colorScheme}`, legendX + 15, yPos);
                yPos += lineHeight;
                
            } else if (canvasId === 'circle') {
                // Phase rotation
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Phase Rotation', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`r/m = ${phaseR}/${phaseM}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                finalCtx.fillText(`${phaseAngleDeg.toFixed(6)}°`, legendX + 15, yPos);
                yPos += lineHeight + sectionGap;
                
                // Residue layers
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Residue Layers', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`Total: ${totalResidues}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                finalCtx.fillText(`Layers: 1 to ${m}`, legendX + 15, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`m(m+1)/2`, legendX + 15, yPos);
                yPos += lineHeight;
                
            } else if (canvasId === 'gcd') {
                // 3D View settings
                const rotX = document.getElementById('rotationX')?.value || 45;
                const rotY = document.getElementById('rotationY')?.value || 45;
                const zoom = document.getElementById('zoomLevel')?.value || 100;
                
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('3D View', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`X-axis: ${rotX}°`, legendX, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`Y-axis: ${rotY}°`, legendX, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`Zoom: ${zoom}%`, legendX, yPos);
                yPos += lineHeight + sectionGap;
                
                // Coprime pairs
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Coprime Pairs', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`Count: ${coprimePairs}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                const totalPairs = m * (m - 1) / 2;
                finalCtx.fillText(`Of ${totalPairs} pairs`, legendX + 15, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`${(coprimePairs/totalPairs*100).toFixed(2)}%`, legendX + 15, yPos);
                yPos += lineHeight;
                
            } else if (canvasId === 'density') {
                // Basel connection
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Basel Problem', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`6/π² ≈ 0.608`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                const baselRatio = density / baselLimit;
                finalCtx.fillText(`Ratio: ${baselRatio.toFixed(4)}×`, legendX + 15, yPos);
                yPos += lineHeight;
                finalCtx.fillText(`Probability coprime`, legendX + 15, yPos);
                yPos += lineHeight + sectionGap;
                
                // Data range
                finalCtx.font = 'bold 46px Arial';
                finalCtx.fillStyle = '#667eea';
                finalCtx.fillText('Data Points', legendX, yPos);
                yPos += lineHeight + 8;
                
                finalCtx.font = mediumFont;
                finalCtx.fillStyle = '#2d3748';
                finalCtx.fillText(`n = 2 to ${m}`, legendX, yPos);
                yPos += lineHeight;
                
                finalCtx.font = smallFont;
                finalCtx.fillStyle = '#4a5568';
                finalCtx.fillText(`${m - 1} values`, legendX + 15, yPos);
                yPos += lineHeight;
            }
            
            // Footer on final canvas
            finalCtx.fillStyle = '#718096';
            finalCtx.font = '36px Arial';
            finalCtx.textAlign = 'center';
            finalCtx.fillText('Wessen Getachew | github.com/wessengetachew | @7dview', finalCanvas.width / 2, finalCanvas.height - 50);
            finalCtx.font = '32px Arial';
            finalCtx.fillText(new Date().toLocaleDateString(), finalCanvas.width / 2, finalCanvas.height - 15);
            
            finalCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `modular_${canvasId}_m${m}_with_legend.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
            
            showNotification('Export Complete', `${info.title} exported with comprehensive legend`);
        }

        function exportAllCanvases() {
            try {
                const m = parseInt(document.getElementById('modulusInput').value);
                const units = findUnits(m);
                const zeroDivisors = findZeroDivisors(m);
                const idempotents = findIdempotents(m);
                const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
                const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
                const totalResidues = (m * (m + 1)) / 2;
                const coprimeDensity = units.length / m;
                
                const canvases = [
                    { 
                        id: 'gridCanvas', 
                        title: '⊗ Multiplication Table',
                        metrics: `φ(${m})=${units.length} units`
                    },
                    { 
                        id: 'circleCanvas', 
                        title: '○ Farey Channels',
                        metrics: `${totalResidues} residues · Phase ${phaseR}/${phaseM}`
                    },
                    { 
                        id: 'gcdCanvas', 
                        title: '⊚ GCD 3D Sphere',
                        metrics: `360° rotation · Density ${coprimeDensity.toFixed(4)}`
                    },
                    { 
                        id: 'densityCanvas', 
                        title: '◬ Coprime Density',
                        metrics: `φ(m)/m trend · Basel 6/π²`
                    }
                ];
                
                // Get export resolution
                const exportResolution = getExportResolution();
                const scale = exportResolution / 3840;
                
                // Create wider canvas to include legend
                const margin = 250 * scale;
                const gridWidth = exportResolution * 2;
                const gridHeight = exportResolution * 2;
                
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = gridWidth;
                exportCanvas.height = gridHeight + margin;
                const ctx = exportCanvas.getContext('2d', { alpha: false });
                
                // White background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
                
                // Main title
                ctx.fillStyle = '#1a202c';
                ctx.font = `bold ${96 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('Modular Arithmetic Explorer', gridWidth / 2, 100 * scale);
                
                // Subtitle with m and key metrics
                ctx.font = `${56 * scale}px Arial`;
                ctx.fillStyle = '#4a5568';
                ctx.fillText(`m = ${m} · Ring ℤ/${m}ℤ · φ(${m}) = ${units.length} · Prime: ${isPrime(m) ? 'Yes' : 'No'}`, gridWidth / 2, 180 * scale);
                
                // Draw 2x2 grid of canvases
                canvases.forEach((info, idx) => {
                    const sourceCanvas = document.getElementById(info.id);
                    if (!sourceCanvas) return;
                    
                    const col = idx % 2;
                    const row = Math.floor(idx / 2);
                    const x = col * exportResolution;
                    const y = row * exportResolution + margin;
                    
                    // Draw border
                    ctx.strokeStyle = '#cbd5e0';
                    ctx.lineWidth = 4 * scale;
                    ctx.strokeRect(x, y, exportResolution, exportResolution);
                    
                    // Draw canvas
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.scale(exportResolution / sourceCanvas.width, exportResolution / sourceCanvas.height);
                    ctx.drawImage(sourceCanvas, 0, 0);
                    ctx.restore();
                    
                    // Draw title at top of each panel
                    ctx.fillStyle = '#2d3748';
                    ctx.font = `bold ${56 * scale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(info.title, x + exportResolution / 2, y + 80 * scale);
                    
                    // Draw metrics at bottom of each panel
                    ctx.font = `${40 * scale}px Arial`;
                    ctx.fillStyle = '#718096';
                    ctx.fillText(info.metrics, x + exportResolution / 2, y + exportResolution - 40 * scale);
                });
                
                // Footer
                ctx.fillStyle = '#718096';
                ctx.font = `${48 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('Wessen Getachew | github.com/wessengetachew | @7dview', exportCanvas.width / 2, exportCanvas.height - 60 * scale);
                ctx.font = `${40 * scale}px Arial`;
                ctx.fillText(new Date().toLocaleDateString(), exportCanvas.width / 2, exportCanvas.height - 15 * scale);
                
                exportCanvas.toBlob(blob => {
                    if (!blob) {
                        showNotification('Export Error', 'Failed to create image blob');
                        return;
                    }
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `modular_all_4_canvases_m${m}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showNotification('Export Complete', 'All 4 canvases exported successfully');
                }, 'image/png');
            } catch (err) {
                console.error('Export all error:', err);
                showNotification('Export Error', 'Failed to export: ' + err.message);
            }
        }

        function exportWithAnalysis() {
            try {
                const m = parseInt(document.getElementById('modulusInput').value);
                const tableTypeElem = document.querySelector('input[name="tableTypeCanvas1"]:checked') || 
                                     document.querySelector('input[name="tableType"]:checked');
                const colorSchemeElem = document.querySelector('input[name="colorSchemeCanvas1"]:checked') || 
                                       document.querySelector('input[name="colorScheme"]:checked');
                const tableType = tableTypeElem ? tableTypeElem.value : 'multiplication';
                const colorScheme = colorSchemeElem ? colorSchemeElem.value : 'rainbow';
            
            const units = findUnits(m);
            const zeroDivisors = findZeroDivisors(m);
            const idempotents = findIdempotents(m);
            const isField = isPrime(m);
            
            // Get phase rotation for circle canvas
            const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
            const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
            const phaseAngleDeg = (360 * phaseR) / phaseM;
            
            // Calculate additional statistics
            const nilpotents = [];
            for (let a = 0; a < m; a++) {
                let temp = a;
                for (let n = 1; n < 20; n++) {
                    temp = (temp * a) % m;
                    if (temp === 0) {
                        nilpotents.push(a);
                        break;
                    }
                }
            }
            
            // Count GCD values
            const gcdDistribution = new Map();
            for (let r = 0; r < m; r++) {
                const g = gcd(r, m);
                gcdDistribution.set(g, (gcdDistribution.get(g) || 0) + 1);
            }
            
            // Calculate coprime density
            const coprimeDensity = units.length / m;
            const baselLimit = 6 / (Math.PI * Math.PI);
            
            // Prime factorization details
            const primeFactors = [];
            let temp = m;
            for (let p = 2; p <= temp; p++) {
                let count = 0;
                while (temp % p === 0) {
                    count++;
                    temp /= p;
                }
                if (count > 0) {
                    primeFactors.push({ prime: p, power: count });
                }
            }
            
            const canvases = [
                { 
                    id: 'gridCanvas', 
                    title: '⊗ Multiplication Table',
                    color: '#FF6B9D' // Pink
                },
                { 
                    id: 'circleCanvas', 
                    title: '○ Farey Channels',
                    color: '#4ECDC4' // Cyan
                },
                { 
                    id: 'gcdCanvas', 
                    title: '⊚ GCD 3D Sphere',
                    color: '#95E1D3' // Light Cyan
                },
                { 
                    id: 'densityCanvas', 
                    title: '◬ Coprime Density',
                    color: '#9F7AEA' // Purple
                }
            ];
            
            // Get export resolution
            const exportResolution = getExportResolution();
            const scale = exportResolution / 3840;
            
            // Count additional metrics
            const totalResidues = (m * (m + 1)) / 2;
            const rotX = document.getElementById('rotationX')?.value || 45;
            const rotY = document.getElementById('rotationY')?.value || 45;
            const zoom = document.getElementById('zoomLevel')?.value || 100;
            
            let coprimePairs = 0;
            for (let a = 0; a < m; a++) {
                for (let b = a + 1; b < m; b++) {
                    if (gcd(a, b) === 1) coprimePairs++;
                }
            }
            
            const margin = 250 * scale;
            const legendWidth = 1000 * scale;
            const canvasSize = exportResolution;
            const gridWidth = canvasSize * 2;
            const gridHeight = canvasSize * 2;
            
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = gridWidth + legendWidth;
            exportCanvas.height = gridHeight + margin;
            const ctx = exportCanvas.getContext('2d', { alpha: false });
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Title
            ctx.fillStyle = '#1a202c';
            ctx.font = 'bold 96px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Modular Arithmetic - Complete Analysis', gridWidth / 2, 100);
            
            // Subtitle
            ctx.font = '56px Arial';
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`m = ${m} · Ring ℤ/${m}ℤ · φ(${m}) = ${units.length} · Prime: ${isField ? 'Yes' : 'No'}`, gridWidth / 2, 175);
            
            // Draw 2×2 grid of ALL canvases with colored borders
            canvases.forEach((info, idx) => {
                const canvas = document.getElementById(info.id);
                if (!canvas) return;
                
                const col = idx % 2;
                const row = Math.floor(idx / 2);
                const x = col * canvasSize;
                const y = row * canvasSize + margin;
                
                // Draw colored border (thicker)
                ctx.strokeStyle = info.color;
                ctx.lineWidth = 12 * scale;
                ctx.strokeRect(x, y, canvasSize, canvasSize);
                
                // Canvas
                ctx.save();
                ctx.translate(x, y);
                const sourceCanvas = document.getElementById(info.id);
                ctx.scale(canvasSize / sourceCanvas.width, canvasSize / sourceCanvas.height);
                ctx.drawImage(sourceCanvas, 0, 0);
                ctx.restore();
                
                // Label with matching color background
                ctx.fillStyle = info.color;
                ctx.fillRect(x + 20 * scale, y + 20 * scale, 600 * scale, 80 * scale);
                ctx.fillStyle = '#ffffff';
                ctx.font = `bold ${52 * scale}px Arial`;
                ctx.textAlign = 'left';
                ctx.fillText(info.title, x + 40 * scale, y + 70 * scale);
            });
            
            // ========== COMPREHENSIVE ANALYSIS PANEL ==========
            const legendX = gridWidth + 40 * scale;
            const legendY = margin;
            
            ctx.fillStyle = '#f7fafc';
            ctx.fillRect(legendX - 20 * scale, legendY - 20 * scale, legendWidth - 60 * scale, gridHeight + 40 * scale);
            ctx.strokeStyle = '#cbd5e0';
            ctx.lineWidth = 5 * scale;
            ctx.strokeRect(legendX - 20 * scale, legendY - 20 * scale, legendWidth - 60 * scale, gridHeight + 40 * scale);
            
            ctx.fillStyle = '#2d3748';
            ctx.font = `bold ${64 * scale}px Arial`;
            ctx.textAlign = 'left';
            ctx.fillText('Analysis', legendX, legendY + 70 * scale);
            
            let yPos = legendY + 150 * scale;
            const lineHeight = 52 * scale;
            const sectionGap = 65 * scale;
            const smallFont = `${38 * scale}px Arial`;
            const mediumFont = `${44 * scale}px Arial`;
            
            // ========== CANVAS COLOR LEGEND ==========
            ctx.font = `bold ${54 * scale}px Arial`;
            ctx.fillStyle = '#667eea';
            ctx.fillText('Canvas Legend', legendX, yPos);
            yPos += lineHeight + 10 * scale;
            
            canvases.forEach((info) => {
                ctx.fillStyle = info.color;
                ctx.fillRect(legendX, yPos - 30 * scale, 40 * scale, 40 * scale);
                
                ctx.fillStyle = '#2d3748';
                ctx.font = mediumFont;
                ctx.fillText(info.title, legendX + 60 * scale, yPos);
                yPos += lineHeight;
            });
            yPos += sectionGap;
            
            // ========== MODULUS PROPERTIES ==========
            ctx.font = `bold ${54 * scale}px Arial`;
            ctx.fillStyle = '#667eea';
            ctx.fillText('Modulus', legendX, yPos);
            yPos += lineHeight + 10 * scale;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`m = ${m}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`Prime factorization:`, legendX, yPos);
            yPos += lineHeight;
            ctx.fillText(`${getPrimeFactorization(m)}`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            
            if (isField) {
                ctx.fillStyle = '#48BB78';
                ctx.fillText(`✓ Prime: Forms a field`, legendX + 20 * scale, yPos);
            } else {
                ctx.fillStyle = '#718096';
                ctx.fillText(`Composite: Has zero divisors`, legendX + 20 * scale, yPos);
            }
            yPos += sectionGap;
            
            // ========== UNIT GROUP ==========
            ctx.font = `bold ${54 * scale}px Arial`;
            ctx.fillStyle = '#667eea';
            ctx.fillText('Unit Group', legendX, yPos);
            yPos += lineHeight + 10 * scale;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`φ(${m}) = ${units.length}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`Density: ${coprimeDensity.toFixed(6)}`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`Basel limit: ${baselLimit.toFixed(6)}`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`Ratio: ${(coprimeDensity/baselLimit).toFixed(4)}×`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            
            if (units.length <= 20) {
                ctx.fillText(`Units: {${units.join(',')}}`, legendX + 20 * scale, yPos);
                yPos += lineHeight;
            } else {
                ctx.fillText(`Units: {${units.slice(0,15).join(',')}, ...}`, legendX + 20 * scale, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap - lineHeight;
            
            // ========== ZERO DIVISORS ==========
            ctx.font = `bold ${46 * scale}px Arial`;
            ctx.fillStyle = '#667eea';
            ctx.fillText('Zero Divisor Structure', legendX, yPos);
            yPos += lineHeight + 10 * scale;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`Count: ${zeroDivisors.length}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            const zdDensity = zeroDivisors.length / m;
            ctx.fillText(`Density: ${zdDensity.toFixed(6)}`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`Non-zero ZD: ${zeroDivisors.filter(z => z !== 0).length}`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            
            if (zeroDivisors.length > 0 && zeroDivisors.length <= 15) {
                ctx.fillText(`Set: {${zeroDivisors.join(',')}}`, legendX + 20 * scale, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap - lineHeight;
            
            // ========== IDEMPOTENT STRUCTURE ==========
            ctx.font = `bold ${46 * scale}px Arial`;
            ctx.fillStyle = '#667eea';
            ctx.fillText('Idempotent Structure', legendX, yPos);
            yPos += lineHeight + 10 * scale;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            ctx.fillText(`Count: ${idempotents.length}`, legendX, yPos);
            yPos += lineHeight;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            const numPrimeFactors = primeFactors.length;
            const expectedIdempotents = Math.pow(2, numPrimeFactors);
            ctx.fillText(`Expected (2^ω(m)): ${expectedIdempotents}`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            
            if (idempotents.length <= 15) {
                ctx.fillText(`Set: {${idempotents.join(',')}}`, legendX + 20 * scale, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap - lineHeight;
            
            // ========== GCD DISTRIBUTION ==========
            ctx.font = `bold ${46 * scale}px Arial`;
            ctx.fillStyle = '#667eea';
            ctx.fillText('GCD Distribution', legendX, yPos);
            yPos += lineHeight + 10 * scale;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            const sortedGCDs = Array.from(gcdDistribution.keys()).sort((a, b) => a - b);
            let gcdCount = 0;
            for (let g of sortedGCDs.slice(0, 8)) {
                const count = gcdDistribution.get(g);
                ctx.fillText(`gcd=${g}: ${count} elements (${(count/m*100).toFixed(1)}%)`, legendX + 20 * scale, yPos);
                yPos += lineHeight;
                gcdCount++;
            }
            if (sortedGCDs.length > 8) {
                ctx.fillText(`... and ${sortedGCDs.length - 8} more`, legendX + 20 * scale, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap - lineHeight;
            
            // ========== CANVAS DETAILS ==========
            ctx.font = `bold ${54 * scale}px Arial`;
            ctx.fillStyle = '#667eea';
            ctx.fillText('Canvas Details', legendX, yPos);
            yPos += lineHeight + 10 * scale;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`Grid: ${tableType}, ${colorScheme}`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`Circle: Phase ${phaseAngleDeg.toFixed(1)}°, ${totalResidues} res`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`GCD: View ${rotX}°×${rotY}°, zoom ${zoom}%`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`Density: ${m-1} points, coprime ${coprimePairs}`, legendX + 20 * scale, yPos);
            yPos += sectionGap;
            
            // ========== RING CLASSIFICATION ==========
            ctx.font = `bold ${54 * scale}px Arial`;
            ctx.fillStyle = '#667eea';
            ctx.fillText('Classification', legendX, yPos);
            yPos += lineHeight + 10 * scale;
            
            ctx.font = mediumFont;
            ctx.fillStyle = '#2d3748';
            
            const classifications = [];
            if (isField) classifications.push('Field');
            if (zeroDivisors.length === 0) classifications.push('Integral Domain');
            if (units.length === m - 1) classifications.push('Division Ring');
            if (idempotents.length > 2) classifications.push('Non-trivial Idempotents');
            if (nilpotents.length > 1) classifications.push('Has Nilpotents');
            
            for (let i = 0; i < Math.min(classifications.length, 6); i++) {
                ctx.font = smallFont;
                ctx.fillStyle = '#48BB78';
                ctx.fillText(`✓ ${classifications[i]}`, legendX + 20 * scale, yPos);
                yPos += lineHeight;
            }
            
            if (classifications.length === 0) {
                ctx.fillStyle = '#718096';
                ctx.fillText('General commutative ring', legendX + 20 * scale, yPos);
                yPos += lineHeight;
            }
            yPos += sectionGap;
            
            // ========== CANVAS DETAILS ==========
            ctx.font = `bold ${46 * scale}px Arial`;
            ctx.fillStyle = '#667eea';
            ctx.fillText('Canvas Details', legendX, yPos);
            yPos += lineHeight + 10 * scale;
            
            ctx.font = smallFont;
            ctx.fillStyle = '#4a5568';
            ctx.fillText(`⊗ Grid: ${tableType} table`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`○ Circle: ${totalResidues} residues`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`   Phase ${phaseR}/${phaseM} = ${phaseAngleDeg.toFixed(1)}°`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`⊚ GCD: 3D view ${rotX}°×${rotY}°`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`   ${coprimePairs} coprime pairs`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`◬ Density: ${m-1} data points`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            ctx.fillText(`   Ratio: ${(coprimeDensity/baselLimit).toFixed(4)}×`, legendX + 20 * scale, yPos);
            yPos += lineHeight;
            
            // Footer
            ctx.fillStyle = '#718096';
            ctx.font = `${36 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('Wessen Getachew | github.com/wessengetachew | @7dview', exportCanvas.width / 2, exportCanvas.height - 50 * scale);
            ctx.font = `${32 * scale}px Arial`;
            ctx.fillText(new Date().toLocaleDateString(), exportCanvas.width / 2, exportCanvas.height - 15 * scale);
            
            exportCanvas.toBlob(blob => {
                if (!blob) {
                    showNotification('Export Error', 'Failed to create image blob');
                    return;
                }
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const resText = exportResolution === 2048 ? '2K' : exportResolution === 3840 ? '4K' : '8K';
                a.download = `modular_all_4_canvases_m${m}_full_analysis_${resText}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showNotification('Export Complete', `All 4 canvases exported with comprehensive statistical analysis panel at ${resText} resolution`);
            }, 'image/png');
            } catch (err) {
                console.error('Export with analysis error:', err);
                showNotification('Export Error', 'Failed to export: ' + err.message);
            }
        }

        function exportData(dataType) {
            try {
                const m = parseInt(document.getElementById('modulusInput').value);
                const tableTypeElem = document.querySelector('input[name="tableTypeCanvas1"]:checked') || 
                                     document.querySelector('input[name="tableType"]:checked');
                const tableType = tableTypeElem ? tableTypeElem.value : 'multiplication';
                
                let csv = '';
                let filename = '';
                
                if (dataType === 'grid' || dataType === 'all') {
                    csv += '# Multiplication/Addition Table Data\n';
                    csv += '# Modulus m = ' + m + '\n';
                    csv += '# Table Type: ' + tableType + '\n';
                    csv += 'a,b,result,operation\n';
                    
                    const elements = tableType === 'cayley' ? findUnits(m) : Array.from({ length: m }, (_, i) => i);
                    
                    for (let i = 0; i < elements.length; i++) {
                        for (let j = 0; j < elements.length; j++) {
                            const a = elements[i];
                            const b = elements[j];
                            const result = tableType === 'addition' ? (a + b) % m : (a * b) % m;
                            const op = tableType === 'addition' ? 'addition' : 'multiplication';
                            csv += `${a},${b},${result},${op}\n`;
                        }
                    }
                    csv += '\n';
                }
                
                if (dataType === 'circle' || dataType === 'all') {
                    const phaseR = parseInt(document.getElementById('phaseNumerator').value) || 0;
                    const phaseM = parseInt(document.getElementById('phaseDenominator').value) || 1;
                    const phaseAngle = (2 * Math.PI * phaseR) / phaseM;
                    const phaseAngleDeg = (360 * phaseR) / phaseM;
                    
                    csv += '# Farey Channel Representation - Unit Circle\n';
                    csv += '# All residues r/mod for moduli from 1 to m\n';
                    csv += `# Phase rotation: ${phaseR}/${phaseM} = ${phaseAngleDeg.toFixed(17)} degrees\n`;
                    csv += 'modulus,residue,fraction,angle_degrees,angle_radians,real,imaginary,gcd_value,is_unit,ring_radius\n';
                    
                    for (let mod = 1; mod <= m; mod++) {
                        const ringRadius = mod / m;
                        
                        for (let r = 0; r < mod; r++) {
                            const gcdVal = gcd(r, mod);
                            const angle = (2 * Math.PI * r) / mod + phaseAngle;
                            const angleDeg = (360 * r) / mod + phaseAngleDeg;
                            const real = Math.cos(angle);
                            const imag = Math.sin(angle);
                            const isUnit = gcdVal === 1 ? 'TRUE' : 'FALSE';
                            const fraction = `${r}/${mod}`;
                            
                            csv += `${mod},${r},${fraction},${angleDeg.toFixed(6)},${angle.toFixed(6)},${real.toFixed(6)},${imag.toFixed(6)},${gcdVal},${isUnit},${ringRadius.toFixed(6)}\n`;
                        }
                    }
                    csv += '\n';
                }
                
                if (dataType === 'gcd' || dataType === 'all') {
                    csv += '# GCD Structure\n';
                    csv += '# Pairwise GCD values\n';
                    csv += 'a,b,gcd_value\n';
                    
                    for (let a = 0; a < m; a++) {
                        for (let b = a + 1; b < m; b++) {
                            const g = gcd(a, b);
                            if (g > 0) {
                                csv += `${a},${b},${g}\n`;
                            }
                        }
                    }
                    csv += '\n';
                }
                
                if (dataType === 'density' || dataType === 'all') {
                    csv += '# Coprime Density Analysis\n';
                    csv += '# Euler totient function φ(n) and density φ(n)/n\n';
                    csv += 'n,phi_n,density,six_over_pi_squared\n';
                    
                    const sixOverPiSq = 6 / (Math.PI * Math.PI);
                    for (let n = 2; n <= m; n++) {
                        const phi = euler_phi(n);
                        const density = phi / n;
                        csv += `${n},${phi},${density.toFixed(6)},${sixOverPiSq.toFixed(6)}\n`;
                    }
                }
                
                // Determine filename
                if (dataType === 'all') {
                    filename = `modular_all_data_m${m}.csv`;
                } else {
                    filename = `modular_${dataType}_data_m${m}.csv`;
                }
                
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('CSV Export Complete', `${dataType === 'all' ? 'All' : dataType.charAt(0).toUpperCase() + dataType.slice(1)} data exported as CSV`);
            } catch (err) {
                console.error('CSV export error:', err);
                showNotification('Export Error', 'Failed to export CSV: ' + err.message);
            }
        }

        // Rest of the existing functions remain the same...

        // Initialize
        window.onload = function() {
            // Load state from URL if present
            loadStateFromURL();
            
            // Initialize visualizations
            updateVisualization();
            
            // Initialize keyboard shortcuts
            initKeyboardShortcuts();
            
            // Initialize 3D mouse controls
            init3DMouseControls();
            
            // Show keyboard shortcuts hint
            setTimeout(() => {
                showNotification('Tip', 'Press <strong>H</strong> for keyboard shortcuts', 3000);
            }, 1000);
        };
        
        // ========== INDEPENDENT CANVAS MODE ==========
        const canvasIndependentStates = {
            grid: { active: false, modulus: 12 },
            circle: { active: false, modulus: 12 },
            gcd: { active: false, modulus: 12 },
            density: { active: false, start: 1, end: 100 }
        };
        
        // Track which canvas dropdowns are expanded
        const canvasControlsExpanded = {
            grid: false,
            circle: false,
            gcd: false,
            density: false
        };
        
        function toggleCanvasControls(canvasId) {
            const controls = document.getElementById(`${canvasId}Controls`);
            const icon = document.getElementById(`${canvasId}ToggleIcon`);
            
            if (canvasControlsExpanded[canvasId]) {
                // Collapse
                controls.style.maxHeight = '0';
                icon.style.transform = 'rotate(0deg)';
                icon.textContent = '▼';
                canvasControlsExpanded[canvasId] = false;
            } else {
                // Expand
                controls.style.maxHeight = controls.scrollHeight + 'px';
                icon.style.transform = 'rotate(180deg)';
                icon.textContent = '▲';
                canvasControlsExpanded[canvasId] = true;
            }
        }
        
        function toggleCanvasMode(canvasId) {
            const checkbox = document.getElementById(`${canvasId}Independent`);
            const controls = document.getElementById(`${canvasId}IndependentControls`);
            
            canvasIndependentStates[canvasId].active = checkbox.checked;
            
            if (checkbox.checked) {
                controls.style.display = 'block';
                // Initialize with current global modulus
                const globalM = parseInt(document.getElementById('modulusInput').value);
                if (canvasId === 'density') {
                    document.getElementById('densityStartValue').value = 1;
                    document.getElementById('densityEndValue').value = Math.max(globalM, 100);
                    canvasIndependentStates[canvasId].start = 1;
                    canvasIndependentStates[canvasId].end = Math.max(globalM, 100);
                } else {
                    document.getElementById(`${canvasId}ModulusValue`).value = globalM;
                    document.getElementById(`${canvasId}ModulusSlider`).value = Math.min(globalM, document.getElementById(`${canvasId}ModulusSlider`).max);
                    canvasIndependentStates[canvasId].modulus = globalM;
                }
                updateIndependentCanvas(canvasId);
                showNotification('Independent Mode', `${canvasId} canvas is now independent. Use its own controls.`);
            } else {
                controls.style.display = 'none';
                // Sync back to global modulus
                updateVisualization();
                showNotification('Unified Mode', `${canvasId} canvas synced back to global controls.`);
            }
        }
        
        function updateIndependentCanvas(canvasId) {
            if (!canvasIndependentStates[canvasId].active) return;
            
            const units = findUnits(12); // temp for params
            const zeroDivisors = findZeroDivisors(12);
            const idempotents = findIdempotents(12);
            
            if (canvasId === 'grid') {
                const m = parseInt(document.getElementById('gridModulusValue').value);
                canvasIndependentStates.grid.modulus = m;
                const tableType = document.querySelector('input[name="tableTypeCanvas1"]:checked')?.value || 'multiplication';
                const colorScheme = document.querySelector('input[name="colorSchemeCanvas1"]:checked')?.value || 'rainbow';
                const showLabels = document.getElementById('showLabels').checked;
                const showGridLines = document.getElementById('showGridLines')?.checked || false;
                const u = findUnits(m);
                const zd = findZeroDivisors(m);
                const idemp = findIdempotents(m);
                drawGridCanvas(m, tableType, colorScheme, showLabels, showGridLines, u, zd, idemp);
                updateLiveStatistics(m, u, zd, idemp, findPrimitiveRoots(m));
            } else if (canvasId === 'circle') {
                const m = parseInt(document.getElementById('circleModulusValue').value);
                canvasIndependentStates.circle.modulus = m;
                const u = findUnits(m);
                const highlightUnits = document.getElementById('highlightUnits')?.checked || false;
                drawCircleCanvas(m, u, highlightUnits);
                updateCircleLiveStats(m);
            } else if (canvasId === 'gcd') {
                const m = parseInt(document.getElementById('gcdModulusValue').value);
                canvasIndependentStates.gcd.modulus = m;
                drawGCDCanvas(m);
                updateGCDLiveStats(m);
            } else if (canvasId === 'density') {
                const start = parseInt(document.getElementById('densityStartValue').value);
                const end = parseInt(document.getElementById('densityEndValue').value);
                canvasIndependentStates.density.start = start;
                canvasIndependentStates.density.end = end;
                drawDensityCanvasRange(start, end);
                updateDensityLiveStats(end);
            }
        }
        
        function setDensityRange(start, end) {
            document.getElementById('densityStartValue').value = start;
            document.getElementById('densityEndValue').value = end;
            updateIndependentCanvas('density');
        }
        
        // Modified updateVisualization to respect independent modes
        const originalUpdateVisualization = updateVisualization;
        function updateVisualization() {
            const m = parseInt(document.getElementById('modulusInput').value);
            
            // Get settings from Canvas 1 controls (preferred) or fallback to global
            let tableType, colorScheme;
            const canvas1Table = document.querySelector('input[name="tableTypeCanvas1"]:checked');
            const canvas1Color = document.querySelector('input[name="colorSchemeCanvas1"]:checked');
            
            if (canvas1Table) {
                tableType = canvas1Table.value;
            } else {
                tableType = document.querySelector('input[name="tableType"]:checked')?.value || 'multiplication';
            }
            
            if (canvas1Color) {
                colorScheme = canvas1Color.value;
            } else {
                colorScheme = document.querySelector('input[name="colorScheme"]:checked')?.value || 'rainbow';
            }
            
            const showLabels = document.getElementById('showLabels').checked;
            const showGridLines = document.getElementById('showGridLines') ? document.getElementById('showGridLines').checked : false;
            const highlightUnits = document.getElementById('highlightUnits') ? document.getElementById('highlightUnits').checked : false;

            // Get special elements
            const units = findUnits(m);
            const zeroDivisors = findZeroDivisors(m);
            const idempotents = findIdempotents(m);

            // Draw only canvases that are NOT in independent mode
            if (!canvasIndependentStates.grid.active) {
                drawGridCanvas(m, tableType, colorScheme, showLabels, showGridLines, units, zeroDivisors, idempotents);
            }
            if (!canvasIndependentStates.circle.active) {
                drawCircleCanvas(m, units, highlightUnits);
            }
            if (!canvasIndependentStates.gcd.active) {
                drawGCDCanvas(m);
            }
            if (!canvasIndependentStates.density.active) {
                drawDensityCanvas(m);
            }

            // Update statistics
            updateStatistics(m, units, zeroDivisors, idempotents);
        }
        
        // ========== NEW TOOL FUNCTIONS ==========
        
        // Circle Canvas Tools
        let circleAnimationInterval = null;
        
        function toggleCircleAnimation() {
            const btn = document.getElementById('circleAnimBtn');
            if (circleAnimationInterval) {
                clearInterval(circleAnimationInterval);
                circleAnimationInterval = null;
                btn.textContent = 'Animate Rotation';
            } else {
                circleAnimationInterval = setInterval(() => {
                    const phaseM = parseInt(document.getElementById('phaseDenominator').value);
                    let phaseR = parseInt(document.getElementById('phaseNumerator').value);
                    phaseR = (phaseR + 1) % phaseM;
                    document.getElementById('phaseNumerator').value = phaseR;
                    updateCircleVisualization();
                }, 200);
                btn.textContent = 'Stop Animation';
            }
        }
        
        function resetCircleView() {
            document.getElementById('phaseNumerator').value = 0;
            document.getElementById('phaseDenominator').value = 1;
            document.getElementById('ringRotation').value = 0;
            document.getElementById('ringRotationValue').textContent = '0°';
            updateCircleVisualization();
            showNotification('Circle View Reset', 'All rotation parameters reset to defaults');
        }
        
        function highlightCoprimeRings() {
            document.getElementById('fadeNonCoprime').checked = true;
            document.getElementById('highlightPrimeGCD').checked = false;
            updateCircleVisualization();
            showNotification('Coprime Highlight', 'Non-coprime points faded, coprime points emphasized');
        }
        
        // GCD Canvas Tools
        function snapToAxis(axis) {
            const rotX = document.getElementById('rotationX');
            const rotY = document.getElementById('rotationY');
            
            if (axis === 'x') {
                rotX.value = 0;
                rotY.value = 90;
            } else if (axis === 'y') {
                rotX.value = 90;
                rotY.value = 0;
            } else if (axis === 'z') {
                rotX.value = 0;
                rotY.value = 0;
            }
            
            updateGCDVisualization();
            showNotification('View Snapped', `Viewing along ${axis.toUpperCase()}-axis`);
        }
        
        // Density Canvas Tools
        function resetDensityYAxis() {
            document.getElementById('yAxisMin').value = 0;
            document.getElementById('yAxisMax').value = 1;
            updateDensityVisualization();
            showNotification('Y-Axis Reset', 'Reset to full range [0, 1]');
        }
        
        function zoomToPrimes() {
            const m = parseInt(document.getElementById('modulusInput').value);
            let minDensity = 1;
            let maxDensity = 0;
            
            for (let n = 2; n <= m; n++) {
                if (isPrime(n)) {
                    const density = euler_phi(n) / n;
                    minDensity = Math.min(minDensity, density);
                    maxDensity = Math.max(maxDensity, density);
                }
            }
            
            const padding = 0.05;
            document.getElementById('yAxisMin').value = Math.max(0, minDensity - padding).toFixed(2);
            document.getElementById('yAxisMax').value = Math.min(1, maxDensity + padding).toFixed(2);
            updateDensityVisualization();
            showNotification('Zoomed to Primes', `Y-axis range optimized for prime densities`);
        }
        
        function fitToData() {
            const m = parseInt(document.getElementById('modulusInput').value);
            let minDensity = 1;
            let maxDensity = 0;
            
            for (let n = 2; n <= m; n++) {
                const density = euler_phi(n) / n;
                minDensity = Math.min(minDensity, density);
                maxDensity = Math.max(maxDensity, density);
            }
            
            const padding = 0.05;
            document.getElementById('yAxisMin').value = Math.max(0, minDensity - padding).toFixed(2);
            document.getElementById('yAxisMax').value = Math.min(1, maxDensity + padding).toFixed(2);
            updateDensityVisualization();
            showNotification('Fitted to Data', `Y-axis optimized for current data range`);
        }
        
        // Grid Canvas Tools
        let isTransposed = false;
        
        function transposeTable() {
            isTransposed = !isTransposed;
            updateVisualization();
            showNotification('Table Transposed', isTransposed ? 'Showing transposed view' : 'Showing normal view');
        }
        
        function compareWithAddition() {
            // Switch to addition table and highlight differences
            const additionRadio = document.querySelector('input[name="tableTypeCanvas1"][value="addition"]');
            if (additionRadio) {
                additionRadio.checked = true;
                updateVisualization();
                showNotification('Switched to Addition', 'Now showing addition table for comparison');
            }
        }
    </script>
</body>
                                                            </html>
